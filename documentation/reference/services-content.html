---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "services.xml - 'content'"
---

<pre>
<a href="#content">content [version, id, distributor-base-port]</a>
    <a href="#documents">documents [selection, garbage-collection, garbage-collection-interval]</a>
        <a href="#document">document [type, selection, mode]</a>
        <a href="#document-processing">document-processing [cluster, chain]</a>
    <a href="#redundancy">redundancy</a>
    <a href="#nodes">nodes</a>
        <a href="#node">node [baseport, hostalias, jvmargs??, preload, distribution-key, capacity]</a>
    <a href="#group">group [distribution-key, name]</a>
        <a href="#distribution">distribution</a>
        <a href="#node">node [baseport, hostalias, jvmargs??, preload, distribution-key, capacity]</a>
        <a href="#group">group [distribution-key, name]</a>
    <a href="#engine">engine</a>
        <a href="#proton">proton</a>
            <a href="#searchable-copies">searchable-copies</a>
            <a href="../content/setup-proton-tuning.html">tuning</a>
            <a href="#flush-on-shutdown">flush-on-shutdown</a>
            <a href="#resource-limits">resource-limits</a>
                <a href="#disk">disk</a>
                <a href="#memory">memory</a>
    <a href="#search">search</a>
        <a href="#query-timeout">query-timeout</a>
        <a href="#visibility-delay">visibility-delay</a>
        <a href="#coverage">coverage</a>
            <a href="#minimum">minimum</a>
            <a href="#min-wait-after-coverage-factor">min-wait-after-coverage-factor</a>
            <a href="#max-wait-after-coverage-factor">max-wait-after-coverage-factor</a>
    <a href="#dispatch">dispatch <strong>DEPRECATED</strong></a>
        <a href="#num-dispatch-groups">num-dispatch-groups <strong>DEPRECATED</strong></a>
        <a href="#dispatch-group">group <strong>DEPRECATED</strong></a>
            <a href="#dispatch-node">node [distribution-key] <strong>DEPRECATED</strong></a>
    <a href="#tuning">tuning</a>
        <a href="#bucket-splitting">bucket-splitting [max-documents, max-size, minimum-bits]</a>
        <a href="#min-node-ratio-per-group">min-node-ratio-per-group</a>
        <a href="#distribution_type">distribution [type]</a>
        <a href="#maintenance">maintenance [start, stop, high]</a>
        <a href="#merges">merges [max-per-node, max-queue-size]</a>
        <a href="#persistence-threads">persistence-threads [lowest-priority-to-block-others, highest-priority-to-block]</a>
            <a href="#thread">thread [lowest-priority, count]</a>
        <a href="#visitors">visitors [thread-count, max-queue-size]</a>
            <a href="#max-concurrent">max-concurrent [fixed, variable]</a>
        <a href="#dispatch-tuning">dispatch</a>
            <a href="#max-hits-per-partition">max-hits-per-partition</a>
            <a href="#dispatch-policy">dispatch-policy</a>
            <a href="#min-group-coverage">min-group-coverage</a>
            <a href="#min-active-docs-coverage">min-active-docs-coverage</a>
        <a href="#cluster-controller">cluster-controller</a>
            <a href="#init-progress-time">init-progress-time</a>
            <a href="#transition-time">transition-time</a>
            <a href="#max-premature-crashes">max-premature-crashes</a>
            <a href="#stable-state-period">stable-state-period</a>
            <a href="#min-distributor-up-ratio">min-distributor-up-ratio</a>
            <a href="#min-storage-up-ratio">min-storage-up-ratio</a>
</pre>


<h2 id="content">content</h2>
<p>
The root element of a Content cluster definition.
Creates a content cluster. A content cluster stores and/or indexes documents.
The xml file may have zero or more such tags.
</p><p>
Contained in <code><a href="services.html">services</a></code>. Attributes:
<ul>
  <li><strong>version (required)</strong>:
    Must be set to '1.0' in this version of Vespa.
  </li>
  <li><strong>id (required for multiple clusters)</strong>:
    Name of the content cluster. If none is supplied, the cluster name will be 'content'.
    Cluster names must be unique within application,
    so if several clusters are setup, name must be set for all but one at minimum.
    Suggested set by everyone for cluster to have a meaningful name.
    Allows you to add clusters later without having to rename existing one for the names to make sense.
  </li>
  <li><strong>distributor-base-port (optional)</strong>:
    If a specific port is required for access to the distributor, override it with this attribute.
  </li>
</ul>
Required subelements:
<ul>
  <li><a href="#documents"><code>documents</code></a></li>
  <li><a href="#redundancy"><code>redundancy</code></a></li>
</ul>
Optional subelements:
<ul>
  <li><a href="#nodes"><code>nodes</code></a></li>
  <li><a href="#group"><code>group</code></a></li>
  <li><a href="#engine"><code>engine</code></a></li>
  <li><a href="#search"><code>search</code></a></li>
  <li><a href="#dispatch"><code>dispatch</code></a></li>
  <li><a href="#tuning"><code>tuning</code></a></li>
</ul>
</p>



<h2 id="documents">documents</h2>
<p>
Contained in <code><a href="#content">content</a></code>.
Defines which document types should be routed to this content cluster using the default route,
and what documents should be kept in the cluster if the garbage collector runs.
Read more on <a href="../documents.html#document-expiry">expiring documents</a>.
Also have some backend specific configuration for whether documents should be searchable or not. Attributes:
<table class="table">
<thead>
<tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
</thead><tbody>
<tr id="documents.selection"><th>selection</th>
  <td>optional</td>
  <td>string</td>
  <td></td>
  <td>
    A <a href="document-select-language.html">document selection</a> string,
    defaults to a selection expression matching everything -
    restricts the documents that are routed to this cluster.
    This selection can be specified to match document identifier specifics
    that are <em>independent</em> of document types.
    For restrictions that apply only to a specific document type, this must be done within
    that particular document type's <code>&lt;document&gt;</code> tag.
    Trying to use document type references in this selection will produce an error during deployment.
    The selection given here will be merged with per-document
    type selections specified within document tags, if any, meaning that any
    document in the cluster must match <em>both</em> selections to be accepted and kept.
  </td></tr>
<tr id="documents.garbage-collection"><th>garbage-collection</th>
  <td>optional</td>
  <td>true / false</td>
  <td>false</td>
  <td>
    If true, regularly verify the documents stored in the cluster to see if
    they belong in the cluster, and delete them if not.
    If false, garbage collection is not run.
  </td></tr>
<tr id="documents.garbage-collection-interval"><th style="white-space: nowrap">garbage-collection-interval</th>
  <td>optional</td>
  <td>integer</td>
  <td>3600</td>
  <td>
    Time (in seconds) between garbage collection cycles.
  </td></tr>
</tbody>
</table>
Subelements:
<ul>
  <li><a href="#document"><code>document</code></a> (required)</li>
  <li><a href="#document-processing"><code>document-processing</code></a> (optional)</li>
</ul>
</p>



<h2 id="document">document</h2>
<p>
Contained in <code><a href="#documents">documents</a></code>.
The document type to be routed to this content cluster. Attributes:
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr id="document.type"><th>type</th>
      <td>required</td>
      <td>string</td>
      <td></td>
      <td>
        <a href="search-definitions-reference.html#document">Document type name</a>
      </td></tr>
    <tr id="document.mode"><th>mode</th>
      <td>required</td>
      <td style="white-space: nowrap">index /<br/>store-only /<br/>streaming</td>
      <td></td>
      <td>
        <p>
          The mode of storing and indexing.
          In this documentation, <em>index</em> is assumed unless explicitly mentioned
          <em><a href="../streaming-search.html">streaming</a></em> or <em>store-only</em>.
          Refer to <em>streaming search</em> for <em>store-only</em>, as documents are stored
          the same way for both cases.
        </p><p>
          Changing mode requires an <em>indexing-mode-change</em>
          <a href="validation-overrides.html">validation override</a>,
          and documents must be re-fed.
        </p>
      </td></tr>
    <tr id="document.selection"><th>selection</th>
      <td>optional</td>
      <td>string</td>
      <td></td>
      <td>
        A <a href="document-select-language.html">document selection</a> string,
        defaults to a selection expression matching everything -
        restricts the documents that are routed to this cluster.
        This selection must apply to fields in this document type only.
        Selection will be merged together with selection for other types and global selection from
        <a href="#documents">documents</a> to form a full expression for what documents belong to this cluster.
      </td></tr>
    <tr id="document.global"><th>global</th>
      <td>optional</td>
      <td>true / false</td>
      <td>false</td>
      <td>
        <p>
          Set to <em>true</em> to distribute all documents of this type to all nodes.
          Fields in global documents can be imported into documents to implement joins -
          read more in <a href="../parent-child.html">parent/child</a>.
          Vespa will detect when a new (or outdated) node is added to the cluster
          and prevent it from taking part in searches until it has received all global documents.
        </p><p>
          Changing from <em>false</em> to <em>true</em> or vice versa requires a <em>global-document-change</em>
          <a href="validation-overrides.html">validation override</a>.
          First, <a href="files-processes-and-ports.html#vespa-start-stop">stop services</a> on all content nodes.
          Then, deploy with the validation override.
          Finally, <a href="files-processes-and-ports.html#vespa-start-stop">start services</a> on all content nodes.
        </p><p>
          Note: <em>global</em> is only supported for <em>mode="index"</em>.
        </p>
      </td></tr>
  </tbody>
</table>



<h2 id="document-processing">document-processing</h2>
<p>
Contained in <code><a href="#documents">documents</a></code>.
Vespa Search specific configuration for which document processing cluster and chain to run index pre processing. Attributes:
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr id="document-processing.cluster"><th>cluster</th>
      <td>optional</td>
      <td>string</td>
      <td>Container cluster on content node</td>
      <td>
        Name of a <a href="services-docproc.html">document-processing</a> container cluster that does index pre processing.
        Use cluster to specify an alternative cluster, other than the default cluster on content nodes.
      </td></tr>
    <tr id="document-processing.chain"><th>chain</th>
      <td>optional</td>
      <td>string</td>
      <td><code>indexing</code> chain</td>
      <td>
        A document processing chain in the container cluster specified by <em>cluster</em> to use for index pre processing.
        The chain must inherit the <code>indexing</code> chain.
      </td></tr>
  </tbody>
</table>
Example - the container cluster enables <a href="services-docproc.html">document-processing</a>,
referred to by the content cluster:
<pre>
&lt;container id="my-indexing-cluster" version="1.0"&gt;
  &lt;document-processing/&gt;
&lt;/container&gt;
&lt;content id="music" version="1.0"&gt;
  &lt;documents&gt;
    &lt;document-processing cluster="my-indexing-cluster"/&gt;
  &lt;/documents&gt;
&lt;/content&gt;
</pre>
To add document processors either before or after the indexer,
declare a chain (inherit <em>indexing</em>) in a <em>document-processing</em> container cluster and add document processors.
Annotate document processors with <code>before=indexingStart</code> or <code>after=indexingEnd</code>.
Configure this cluster and chain as the indexing chain in the content cluster - example:
<pre>
&lt;container id="my-indexing-cluster" version="1.0"&gt;
  &lt;document-processing&gt;
    &lt;chain id="my-document-processors" inherits="indexing"&gt;
      &lt;documentprocessor id="MyDocproc"&gt;
        &lt;before&gt;indexingStart&lt;/before&gt;
      &lt;/documentprocessor&gt;
      &lt;documentprocessor id="MyOtherDocproc"&gt;
        &lt;after&gt;indexingEnd&lt;/after&gt;
      &lt;/documentprocessor&gt;
    &lt;/chain&gt;
  &lt;/document-processing&gt;
&lt;/container&gt;
&lt;content id="music" version="1.0"&gt;
  &lt;documents&gt;
    &lt;document-processing cluster="my-indexing-cluster" chain="my-document-processors" /&gt;
  &lt;/documents&gt;
&lt;/content&gt;
</pre>
</p>



<h2 id="redundancy">redundancy</h2>
<p>
Contained in <code><a href="#content">content</a></code>.
Defines the total number of copies of each piece of data the cluster will maintain to avoid data loss.
Example: with a redundancy of 2, the system tolerates 1 node failure before data becomes unavailable
(until the system has managed to create new replicas on other online nodes).
</p><p>
<code>redundancy</code> can be changed without node restart.
</p>



<h2 id="nodes">nodes</h2>
<p>
Contained in <code><a href="#content">content</a></code>.
Defines the set of content nodes in the cluster - parent for node-elements.
</p>



<h2 id="node">node</h2>
<p>
Contained in <code><a href="#nodes">nodes</a></code> or <code><a href="#group">group</a></code>.
Configures a content node to the cluster. Attributes:
<table class="table">
<thead>
<tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
</thead><tbody>
<tr id="node.distribution-key"><th style="white-space: nowrap">distribution-key</th>
  <td>required</td>
  <td>integer</td>
  <td></td>
  <td>
    <p>
    Sets the distribution key of a node. It is not recommended to change this for a given node.
    It is recommended (but not required) that the set of distribution keys
    in the cluster are contiguous and starting at 0.
    Example: If the biggest distribution key is 499, then the distribution algorithm
    need to calculate 500 random numbers to calculate the correct target.
    It is hence recommended to not leave too many gaps in the distribution key range.
    </p><p>
    Distribution keys are used to identify nodes and groups for the
    <a href="../content/idealstate.html">distribution algorithm</a>.
    If a node changes distribution key, the distribution algorithm regards it as a new node,
    hence buckets are redistributed.
    When merging clusters, one might need to change distribution keys -
    details on <a href="../elastic-vespa.html#merge-clusters">merging clusters</a>.
    </p><p>
    Content nodes need unique node distribution keys across the whole cluster,
    as the key is also used as a node identifier where group information is not specified.
    </p>
  </td></tr>
<tr id="node.capacity"><th>capacity</th>
  <td>optional</td>
  <td>double</td>
  <td>1</td>
  <td>
    Capacity of this node, relative to other nodes.
    A node with capacity 2 will get double the data and feed requests of a node with capacity 1. This feature is expert mode only. Don't use if you don't know what you are doing.
  </td></tr>
<tr id="node.baseport"><th>baseport</th>  <!-- ToDo: next 4 attributes are undocumented, still valid? -->
  <td>optional</td>
  <td>integer</td>
  <td></td>
  <td>baseport</td>
  </tr>
<tr id="node.hostalias"><th>hostalias</th>
  <td>optional</td>
  <td>string</td>
  <td></td>
  <td>hostalias</td>
  </tr>
<tr id="node.jvmargs"><th>jvmargs</th>
  <td>optional</td>
  <td>string</td>
  <td></td>
  <td>jvmargs</td>
  </tr>
<tr id="node.preload"><th>preload</th>
  <td>optional</td>
  <td>string</td>
  <td></td>
  <td>preload</a></td>
  </tr>
</tbody>
</table>



<h2 id="group">group</h2>
<p>
Contained in <code><a href="#content">content</a></code> or
<code><a href="#group">group</a></code> - groups can be nested.
Defines the hierarchical distribution structure of the cluster.
Can not be used in conjunction with the <code><a href="#nodes">nodes</a></code> element.
If a non-flat structure is desired, use this element instead.
Groups can contain other groups or nodes, but not both.
In <b>Open Source Vespa</b> when using groups, <code><a href="#searchable-copies">searchable-copies</a></code> and
<code><a href="#redundancy">redundancy</a></code> becomes the total number across all leaf groups in the cluster.
For groups in <b>Vespa Cloud</b> see <a href="https://cloud.vespa.ai/reference/services-hosted.html">separate documentation</a>.
Read more on using <a href="../elastic-vespa.html#grouped-distribution">groups</a>. Attributes:
<table class="table">
<thead>
<tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
</thead><tbody>
<tr id="group.distribution-key"><th style="white-space: nowrap">distribution-key</th>
  <td>required</td>
  <td>integer</td>
  <td></td>
  <td>
    Sets the distribution key of a group. It is not allowed to change this for a given group.
    Group distribution keys only need to be unique among groups that share the same parent group.
  </td></tr>
<tr id="group.name"><th>name</th>
  <td>required</td>
  <td>string</td>
  <td></td>
  <td>The name of the group, used for access from status pages and the like.
  </td></tr>
</tbody>
</table>
</p><p class="alert alert-danger">
There is currently no deployment-time verification that the distribution key
remains unchanged for any given node or group.
Consequently, take great care when modifying the set of nodes in a content cluster.
Assigning a new distribution key to an existing node is undefined behavior;
Best case, the existing data will be temporarily unavailable until the error has been corrected.
Worst case, risk crashes or data loss.
</p><p>See <a href="../performance/sizing-search.html">Vespa Serving Scaling Guide</a> for when to consider using 
grouped distribution and <a href="../performance/sizing-examples.html">Examples</a> for example deployments using
flat and grouped distribution.</p>



<h2 id="distribution">distribution (in group)</h2>
<p>
Contained in <code><a href="#group">group</a></code>.
Defines the data distribution to subgroups of this group.
<em>distribution</em> should not be in the lowest level group containing storage nodes,
as here the ideal state algorithm is used directly.
In higher level groups, <em>distribution</em> is mandatory. Attributes:
<ul>
  <li><strong>partitions (required, if there are subgroups in the group)</strong>:
    String conforming to the <em>partition specification</em>
  </li>
</ul>
<table class="table">
  <thead>
    <tr><th>Partition specification</th><th>Description</th></tr>
  </thead><tbody>
    <tr><th>*</th><td>Distribute all copies over 1 of N groups</td></tr>
    <tr><th>*|*</th><td>Distribute all copies over 2 of N groups</td></tr>
    <tr><th>*|*|*</th><td>Distribute all copies over 3 of N groups</td></tr>
  </tbody>
</table>
The partition specification is used to evenly distribute content copies across groups.
You must write one <code>*</code> per group separated by pipes (e.g. <code>*|*</code> for two groups). See <a href="../performance/sizing-examples.html">Sample deployment configurations</a>.
</p>



<h2 id="engine">engine</h2>
<p>
Contained in <code><a href="#content">content</a></code>.
Specify the content engine to use, and/or adjust tuning parameters for the engine.
Allowed engines are <code>proton</code> and <code>dummy</code>,
the latter being used for debugging purposes. If no engine is given, proton is used.
Sub-elements: one of <a href="#proton"><code>&lt;proton&gt;</code></a> and <code>&lt;dummy&gt;</code>.
</p>



<h2 id="proton">proton</h2>
<p>
Contained in <code><a href="#engine">engine</a></code>.
If specified, the content cluster will use the Proton content engine.
This engine supports storage, indexed search and secondary indices.
Optional sub-elements are <a href="#searchable-copies"><code>searchable-copies</code></a>,
<a href="../content/setup-proton-tuning.html"><code>tuning</code></a>,
<a href="#flush-on-shutdown"><code>flush-on-shutdown</code></a>, and
<a href="#resource-limits"><code>resource-limits</code></a>.
</p>



<h2 id="searchable-copies">searchable-copies</h2>
<p>
Contained in <code><a href="#proton">proton</a></code>.
Default value is 2, or <a href="#redundancy">redundancy</a>, if lower.
If set to less than redundancy, only some of the stored copies are ready for searching at any time.
This means that node failures causes temporary data unavailability
while the alternate copies are being indexed for search.
The benefit is using less memory, trading off availability during transitions.
Refer to <a href="../proton.html#bucket-move">bucket move</a>.
</p><p>
If updating documents or using <a href="#documents">document selection</a> for garbage collection,
consider setting <a href="search-definitions-reference.html#attribute"><code>fast-access</code></a>
on the subset of attribute fields used for this to make sure that these attributes are always kept
in memory for fast access.
Note that this is only useful if <code>searchable-copies</code> is less than <code>redundancy</code>.
</p><p>
<code>searchable-copies</code> can be changed without node restart.
</p>




<h2 id="flush-on-shutdown">flush-on-shutdown</h2>
<p>
Contained in <code><a href="#proton">proton</a></code>. Default value is true.
If set to true, search nodes will flush a set of components (e.g. memory index, attributes) to disk
before shutting down such that the time it takes to flush these components
plus the time it takes to replay the <a href="../proton.html#transaction-log">transaction log</a>
after restart is as low as possible.
The time it takes to replay the transaction log depends on the amount of data to replay,
so by flushing, some components before restart the transaction log will be pruned
and we reduce the replay time significantly.
Refer to <a href="../proton.html#proton-maintenance-jobs">Proton maintenance jobs</a>.
</p>



<h2 id="resource-limits">resource-limits</h2>
<p>
Contained in <code><a href="#proton">proton</a></code>.
Specifies resource limits used by proton to reject write operations when a limit is reached.
Use this to implement a <a href="../writing-to-vespa.html#feed-block">feed block</a>
to avoid saturating content nodes. Elements:
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr id="disk"><th>disk</th>
      <td>optional</td>
      <td>float<br/>[0, 1]</td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/searchcore/src/vespa/searchcore/config/proton.def">
        writefilter.disklimit</a></td>
      <td>Fraction of total space on the disk partition used before put and update operations are rejected</td></tr>
    <tr id="memory"><th>memory</th>
      <td>optional</td>
      <td>float<br/>[0, 1]</td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/searchcore/src/vespa/searchcore/config/proton.def">
        writefilter.memorylimit</a></td>
      <td>Fraction of physical memory that can be resident memory in anonymous mapping by proton
        before put and update operations are rejected</td></tr>
  </tbody>
</table>
Example:
<pre>
&lt;proton&gt;
  &lt;resource-limits&gt;
    &lt;disk&gt;0.90&lt;/disk&gt;
    &lt;memory&gt;0.95&lt;/memory&gt;
</pre>
</p>



<h2 id="search">search</h2>
<p>
Contained in <code><a href="#content">content</a></code>, optional.
Declares search configuration for this content cluster. Optional sub-elements are
<a href="#query-timeout"><code>query-timeout</code></a>,
<a href="#visibility-delay"><code>visibility-delay</code></a> and
<a href="#coverage"><code>coverage</code></a>.
</p>



<h2 id="query-timeout">query-timeout</h2>
<p>
Contained in <a href="#search"><code>search</code></a>.
Specifies the query timeout in seconds for queries against the search interface on the content nodes.
The default is 0.5 (Equal to 500ms), the max is 600.0.
For query timeout also see the request parameter <a href="search-api-reference.html#timeout">timeout</a>.
</p><p>
<strong>Note:</strong> You will not be able to override the configured value using the request parameter
<a href="search-api-reference.html#timeout">timeout</a>.
</p>



<h2 id="visibility-delay">visibility-delay</h2>
<p>Contained in:<a href="#search"><code>search</code></a>.
Specifies the maximum amount of time (in seconds) that should pass from a write operation is
performed, to the change is visible, in search results. The default value is 0 seconds (No buffering) and max allowed value is 1 seconds.

This setting impacts feed performance and 
also controls the TTL caching for parent-child imported fields. 
Note that by increasing this value you should also expect an increase in throughput during batch feeding.
</p><p>
When benchmarking batch feeding for a given test set, we got the following improvements
in throughput when setting <code>visibility-delay</code> to 1.0 seconds:
+20% during initial feeding, +15% during re-feeding and +120% during removing of 1M documents.
These improvements depend on how many index and attribute fields are in the search definition,
the content of the documents and the <code>visibility-delay</code> itself.
Benchmarking is required to establish the particular improvements for a given application.
</p>



<h2 id="coverage">coverage</h2>
<p>Contained in:<a href="#search"><code>search</code></a>.
Declares search coverage configuration for this content cluster. Optional sub-elements are
<a href="#minimum"><code>minimum</code></a>,
<a href="#min-wait-after-coverage-factor"><code>min-wait-after-coverage-factor</code></a>and
<a href="#max-wait-after-coverage-factor"><code>max-wait-after-coverage-factor</code></a>.
</p>

<h2 id="minimum">minimum</h2>
<p>
Contained in <a href="#coverage"><code>coverage</code></a>.
Declares the minimum search coverage required before returning the results of a query.
This number is in the range <code>[0, 1]</code>, with 0 being no coverage and 1 being full coverage.
</p><p>
The default is 1; unless configured otherwise a query will not return
until all search nodes have responded within the specified timeout. 
</p>

<h2 id="min-wait-after-coverage-factor">min-wait-after-coverage-factor</h2>
<p>Contained in: <a href="#coverage"><code>coverage</code></a>.
Declares the minimum time for a query to wait for full coverage once the declared
<a href="#minimum">minimum</a> has been reached. This number is a factor that is
multiplied with the time remaining at the time of reaching minimum coverage.
</p><p>
The default is 0; unless configured otherwise a query will return as soon as the
minimum coverage has been reached, and the remaining search nodes appear to be lagging.
</p>

<h2 id="max-wait-after-coverage-factor">max-wait-after-coverage-factor</h2>
<p>Contained in:<a href="#coverage"><code>coverage</code></a>.
Declares the maximum time for a query to wait for full coverage once the declared
<a href="#minimum">minimum</a> has been reached.
This number is a factor that is multiplied with the time remaining
at the time of reaching minimum coverage.
</p><p>
The default is 1; unless configured otherwise a query is allowed to wait its full
timeout for full coverage even after reaching the minimum.
</p>

<h2 id="dispatch">dispatch DEPRECATED</h2>
<p>
Since Vespa-7.109.10, this element as no effect -
<a href="../vespa8-release-notes.html#vespa-dispatch-bin-process-is-removed">details</a>.
</p>

<h2 id="num-dispatch-groups">num-dispatch-groups (in dispatch) DEPRECATED</h2>
<h2 id="dispatch-group">group (in dispatch) DEPRECATED</h2>
<h2 id="dispatch-node">node (in dispatch) DEPRECATED</h2>


<h2 id="tuning">tuning</h2>
<p>Contained in <a href="#content"><code>content</code></a>, optional. Optional tuning parameters are:
<a href="#bucket-splitting"><code>bucket-splitting</code></a>,
<a href="#min-node-ratio-per-group"><code>min-node-ratio-per-group</code></a>,
<a href="#cluster-controller"><code>cluster-controller</code></a>,
<a href="#dispatch-tuning"><code>dispatch</code></a>,
<a href="#distribution_type"><code>distribution</code></a>,
<a href="#maintenance"><code>maintenance</code></a>,
<a href="#merges"><code>merges</code></a>,
<a href="#persistence-threads"><code>persistence-threads</code></a> and
<a href="#visitors"><code>visitors</code></a></td>.
</p>



<h2 id="bucket-splitting">bucket-splitting</h2>
<p>Contained in <a href="#tuning"><code>tuning</code></a>.
The <a href="../content/buckets.html">bucket</a> is the fundamental unit of distribution
and management in a content cluster.
Buckets are auto-split, no need to configure for most applications.
<a href="../streaming-search.html">Streaming search</a> latency is linear with bucket size. Attributes:
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr id="max-documents"><th style="white-space: nowrap">max-documents</th>
      <td>optional</td>
      <td>integer</td>
      <td>1024</td>
      <td>
        Maximum number of documents per content bucket.
        Buckets are split in two if they have more documents than this.
        Keep this value below 16K.
      </td></tr>
    <tr id="max-size"><th>max-size</th>
      <td>optional</td>
      <td>integer</td>
      <td>32MiB</td>
      <td>
        Maximum size (in bytes) of a bucket.
        This is the sum of the serialized size of all documents kept in the bucket.
        Buckets are split in two if they have a larger size than this.
        Keep this value below 100MiB.
      </td></tr>
    <tr id="minimum-bits"><th>minimum-bits</th>
      <td>optional</td>
      <td>integer</td>
      <td></td>
      <td>
        Override the ideal distribution bit count configured for this cluster.
        Prefer to use the <a href="#distribution_type">distribution type</a>
        setting instead if the default distribution bit count does not fit the cluster.
        This variable is intended for testing and to work around possible distribution bit issues.
        Most users should not need this option.
      </td></tr>
  </tbody>
</table>
</p>



<h2 id="min-node-ratio-per-group">min-node-ratio-per-group</h2>
<p>
Contained in <a href="#tuning"><code>tuning</code></a>.
States a lower bound requirement on the ratio of nodes within <em>individual</em> <a href="#group">groups</a>
that must be online and able to accept traffic before the entire group is automatically taken out of service.
Groups are automatically brought back into service when the availability
of its nodes has been restored to a level equal to or above this limit.
</p><p>
Elastic content clusters are often configured to use multiple groups
for the sake of horizontal traffic scaling and/or data availability.
The content distribution system will try to ensure a configured number of replicas is always present
within a group in order to maintain data redundancy.
If the number of available nodes in a group drops too far,
it is possible for the remaining nodes in the group to not have sufficient capacity to take over
storage and serving for the replicas they now must assume responsibility for.
Such situations are likely to result in increased latencies and/or feed rejections caused by resource exhaustion.
Setting this tuning parameter allows the system to instead automatically take down the remaining nodes in the group,
allowing feed and query traffic to fail completely over to the remaining groups.
</p><p>
Valid parameter is a decimal value in the range [0, 1].
Default is 0, which means that the automatic group out-of-service functionality will <em>not</em> automatically take effect.
</p><p>
Example: assume a cluster has been configured with <em>n</em> groups of 4 nodes each
and the following tuning config:
<pre>
&lt;tuning&gt;
  &lt;min-node-ratio-per-group&gt;0.75&lt;/min-node-ratio-per-group&gt;
&lt;/tuning&gt;
</pre>
This tuning allows for 1 node in a group to be down. If 2 or more nodes go down,
all nodes in the group will be marked as down, letting the <em>n-1</em> remaining groups handle all the traffic.
</p><p>
This configuration can be changed live as the system is running and altered limits will take effect immediately.
</p>



<h2 id="distribution_type">distribution (in tuning)</h2>
<p>Contained in <a href="#tuning"><code>tuning</code></a>.
Lets you tune the distribution algorithm used in the cluster. Attributes:
<ul>
  <li>
    <p><strong>type (optional)</strong>: loose | strict | legacy. Defaults to <code>loose</code>.</p>
    <p>When the number of a nodes configured in a system changes over certain limits, the system will
       automatically trigger major redistributions of documents. This is to ensure that
       the number of buckets is appropriate for the number of nodes in the cluster. This enum
       value speficies how aggressive the system should be in triggering such distribution changes.</p>
    <p>The default of <code>loose</code> strikes a balance between rarely altering the distribution
       of the cluster and keeping the skew in document distribution low. It is recommended that you
       use the default mode unless you have empirically observed that it causes too much skew in load
       or document distribution.</p>
    <p>Note that specifying <code>minimum-bits</code> under <a href="#bucket-splitting">bucket-splitting</a>
       overrides this setting and effectively "locks" the distribution in place.</p>
  </li>
</ul>
</p>



<h2 id="maintenance">maintenance</h2>
<p>Contained in <a href="#tuning"><code>tuning</code></a>.
Controls the running time of the bucket maintenance process.
Bucket maintenance verifies bucket content for corruption.
Most users should not need to tweak this. Attributes:
<ul>
  <li><strong>start (required)</strong>: Time string in HH:MM form, e.g. 02:00
    Start of daily maintenance window.
  </li>
  <li><strong>stop (required)</strong>: Time string in HH:MM form, e.g. 05:00
    End of daily maintenance window.
  </li>
  <li><strong>high (required)</strong>: Week day name string, e.g. monday
    Day of week for starting full file verification cycle (more costly than partial file verification)
  </li>
</ul>
</p>



<h2 id="merges">merges</h2>
<p>Contained in <td><a href="#tuning"><code>tuning</code></a>.
  Defines throttling parameters for bucket merge operations. Attributes:
<ul>
  <li><strong>max-per-node (optional)</strong>:
    Maximum number of parallel active bucket merge operations.
  </li>
  <li><strong>max-queue-size (optional)</strong>:
    Maximum size of the merge bucket queue, before reporting BUSY back to the distributors.
  </li>
</ul>
</p>



<h2 id="persistence-threads">persistence-threads</h2>
<p>Contained in <a href="#tuning"><code>tuning</code></a>.
Defines the number of persistence threads per partition on each content node.
A content node executes bucket operations against the persistence engine synchronously in each of these threads.
By default, four threads are created that can handle any priority operation,
as well as two threads reserved for high priority operations.
Optionally, add one or more <a href="#thread"><code>thread</code></a> elements. Attributes:
<ul>
  <li><strong>lowest-priority-to-block-others (optional)</strong>:
    <a href="services.html#clients">Priority</a> indicator (e.g. VERY_HIGH)
    If an operation has equal to or higher priority than this,
    operations with low enough priority to be blocked will not be able to start running
    in other persistence threads for the same partition.
  </li>
  <li><strong>highest-priority-to-block (optional)</strong>:
    <a href="services.html#clients">Priority</a> indicator (e.g. NORMAL_1)
    If an operation has a priority lower than or equal to this priority,
    and there are already operations being processed that have high enough
    priority to block others, this operation will not be started yet,
    even if there is a free persistence thread.
  </li>
</ul>
</p>



<h2 id="thread">thread</h2>
<p>Contained in <a href="#persistence-threads"><code>persistence-threads</code></a>.
Adds a number of threads to process persistence operations on each partition. Attributes
<ul>
  <li><strong>lowest-priority (optional)</strong>:
    <a href="services.html#clients">Priority</a> indicator (e.g. NORMAL_1)
    <p>
    The lowest priority operation these threads are allowed to process.
    Defaults to LOWEST.
    Note that in this context LOWEST refers to the lowest possible priority.
    While in the context of setting operation priority,
    LOWEST is the lowest user settable priority,
    but the content layer itself can create lower priority operations if it wants.
    </p><p class="alert alert-success">
    <strong>Note:</strong> You should always have at least 1 thread capable of processing
    operations with any priority, as the priority of internal operations is
    undefined from the perspective of the end-user
    and some of these may have a very low priority
    (but still be important to <em>eventually</em> process).
    Failing to do so results in operations filling up partition queues that can never be performed.
    </p>
  </li>
  <li><strong>count (optional)</strong>:
    The number of these threads to create.
  </li>
</ul>
</p>



<h2 id="visitors">visitors</h2>
<p>Contained in <a href="#tuning"><code>tuning</code></a>.
  Tuning parameters for visitor operations.
  Might contain <a href="#max-concurrent"><code>&lt;max-concurrent&gt;</code></a>. Attributes:
<ul>
  <li><strong>thread-count (optional)</strong>:
    The maximum number of threads in which to execute visitor operations.
    A higher number of threads may increase performance, but may use more memory.
  </li>
  <li><strong>max-queue-size (optional)</strong>:
    Maximum size of the pending visitor queue, before reporting BUSY back to the distributors.
  </li>
</ul>
</p>



<h2 id="max-concurrent">max-concurrent</h2>
<p>
Contained in <a href="#visitors"><code>visitors</code></a>.
Defines how many visitors can be active concurrently on each storage node.
The number allowed depends on priority - lower priority visitors should not block higher priority visitors completely.
To implement this, specify a fixed and a variable number.
The maximum active is calculated by adjusting the variable component using the priority,
and adding the fixed component. Attributes:
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr><th>fixed</th>
      <td>optional</td>
      <td>number</td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/storage/src/vespa/storage/visiting/stor-visitor.def">16</a></td>
      <td>The fixed component of the maximum active count</td></tr>
    <tr><th>variable</th>
      <td>optional</td>
      <td>number</td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/storage/src/vespa/storage/visiting/stor-visitor.def">64</a></td>
      <td>The variable component of the maximum active count</td></tr>

  </tbody>
</table>

</p>



<h2 id="dispatch-tuning">dispatch</h2>
<p>Contained in <a href="#tuning"><code>tuning</code></a>.
Tune the query-dispatch behavior - child elements:
</p>
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr id="max-hits-per-partition"><th>max-hits-per-partition</th>
      <td>optional</td>
      <td></td>
      <td></td>
      <td>
        Declares the maximum number of hits to return from a single node.
        By default, a query returns the requested number of hits +
        offset from every search node up to the container,
        which in turns orders them globally according to the query,
        then discards all hits beyond the number requested.
        In a system with a large fan-out, this can consume a lot of network bandwidth and the container nodes
        are easily network saturated even if the query is performed in multiple phases. 
      See <a href="../performance/sizing-search.html">Vespa Serving Scaling Guide</a>.
        When there is sufficiently many search nodes,
        assuming an even distribution of the hits,
        it should suffice to only return some fraction of the request number of hits from each node.
        Note that changing this number will have global ordering impact.
        How much is determined by the total number of search nodes involved in the query
        and the magnitude of the hits/offset parameters.</td></tr>
    <tr id="dispatch-policy"><th>dispatch-policy</th>
      <td>optional</td>
      <td>round-robin / adaptive</td>
      <td>round-robin</td>
      <td>
        Configure policy for choosing which group 
        shall receive the next query request.
        However multi-phase
        requests that either requires or benefits from hitting the same group in all phases are always hashed.
        Relevant only for <a href="../performance/sizing-search.html#data-distribution">grouped distribution</a>.
        <ul>
          <li>
            <strong>round-robin</strong>: round-robins between the groups,
            putting uniform load on the groups.
          </li><li>
            <strong>adaptive</strong>: measures latency, preferring lower latency groups,
            useful for heterogeneous groups and handles soft-failing/slow nodes in a group better than round-robin.
          </li>
        </ul>
    <tr id="min-group-coverage"><th>min-group-coverage</th>
      <td>optional</td>
      <td></td>
      <td>100</td>
      <td>
        Coverage required in order to serve from a group - default full coverage.
        Relevant only for <a href="../performance/sizing-search.html#data-distribution">grouped distribution</a>.</td></tr>
    <tr id="min-active-docs-coverage"><th style="white-space: nowrap">min-active-docs-coverage</th>
      <td>optional</td>
      <td></td>
      <td>50</td>
      <td>
        Percentage of active documents a group needs to have
        compared to average of other groups in order to be active for serving queries.
        Because of measurement timing differences, it is not advisable to tune this above 99 percent.
        Relevant only for <a href="../performance/sizing-search.html#data-distribution">grouped distribution</a>.</td></tr>
  </tbody>
</table>



<h2 id="cluster-controller">cluster-controller</h2>
<p>
Contained in <a href="#tuning"><code>tuning</code></a>.
Tuning parameters for the cluster controller managing this cluster - child elements:
<table class="table">
  <thead>
    <tr><th>Name</th><th>Required</th><th>Value</th><th>Default</th><th>Description</th></tr>
  </thead><tbody>
    <tr id="init-progress-time"><th>init-progress-time</th>
      <td>optional</td>
      <td></td>
      <td></td>
      <td>
        If the initialization progress count have not been altered for this amount of seconds,
        the node is assumed to have deadlocked and is set down.
        Note that initialization may actually be prioritized lower now,
        so setting a low value here might cause false positives.
        Though if it is set down for wrong reason,
        when it will finish initialization and then be set up again.</td></tr>
    <tr id="transition-time"><th>transition-time</th>
      <td>optional</td>
      <td></td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/configdefinitions/src/vespa/fleetcontroller.def">
        storage_transition_time</a>
        <a href="https://github.com/vespa-engine/vespa/blob/master/configdefinitions/src/vespa/fleetcontroller.def">
        distributor_transition_time</a></td>
      <td>
        The transition time states how long (in milliseconds) a node will be in maintenance mode
        during what looks like a controlled restart.
        Keeping a node in maintenance mode during a restart allows a restart
        without the cluster trying to create new copies of all the data immediately.
        If the node has not started initializing or got back up within the transition time,
        the node is set down, in which case, new full bucket copies will be created.
        Note separate defaults for distributor and storage (i.e. search) nodes.</td></tr>
    <tr id="max-premature-crashes"><th style="white-space: nowrap">max-premature-crashes</th>
      <td>optional</td>
      <td></td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/configdefinitions/src/vespa/fleetcontroller.def">
        max_premature_crashes</a></td>
      <td>
        The maximum number of crashes allowed before a content node is permanently
        set down by the cluster controller.
        If the node has a stable up or down state for more than the <em>stable-state-period</em>,
        the crash count is reset.
        However, resetting the count will not reenable the node again if it has been disabled -
        restart the cluster controller to reset.</td></tr>
    <tr id="stable-state-period"><th>stable-state-period</th>
      <td>optional</td>
      <td></td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/configdefinitions/src/vespa/fleetcontroller.def">
        stable_state_time_period</a></td>
      <td>
        If a content node's state doesn't change for this many seconds,
        it's state is considered <em>stable</em>, clearing the premature crash count.</td></tr>
    <tr id="min-distributor-up-ratio"><th>min-distributor-up-ratio</th>
      <td>optional</td>
      <td></td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/configdefinitions/src/vespa/fleetcontroller.def">
        min_distributor_up_ratio</a></td>
      <td>
        The minimum ratio of distributors that are required to be <em>up</em> for the
        cluster state to be <em>up</em>.
        </td></tr>
    <tr id="min-storage-up-ratio"><th>min-storage-up-ratio</th>
      <td>optional</td>
      <td></td>
      <td><a href="https://github.com/vespa-engine/vespa/blob/master/configdefinitions/src/vespa/fleetcontroller.def">
        min_storage_up_ratio</a></td>
      <td>
        The minimum ratio of content nodes that are required to be <em>up</em> for the
        cluster state to be <em>up</em>.</td></tr>
  </tbody>
</table>
