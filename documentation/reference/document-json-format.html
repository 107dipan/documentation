---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Document JSON Format"
---

<p>
This document describes the JSON format used for sending document operations to Vespa.
Field names and types are defined in the
<a href="search-definitions-reference.html#field-types">search definition reference</a>.
</p><p>
Also refer to <a href="../troubleshooting-encoding.html">encoding troubleshooting</a>.
</p>



<h2 id="field-types">Field types</h2>
<table class="table">
  <tr id="string">
    <th>string</th>
    <td>
      <p>
<pre>
"name": "Polly"
</pre>
      </p>
    </td>
  </tr><tr id="int">
    <th>int</th>
    <td>
      <p>
<pre>
"age": 42
</pre>
      </p>
    </td>
  </tr><tr id="long">
    <th>long</th>
    <td>
      <p>
<pre>
"age": 42
</pre>
      </p>
    </td>
  </tr><tr id="bool">
    <th>bool</th>
    <td>
      <p>
<pre>
"alive": false
</pre>
      </p>
    </td>
  </tr><tr id="byte">
    <th>byte</th>
    <td>
      <p>
<pre>
"tinynumber": 128
</pre>
      </p>
    </td>
  </tr><tr id="float">
    <th>float</th>
    <td>
      <p>
<pre>
"weight": 123.4567
</pre>
      </p>
    </td>
  </tr><tr id="double">
    <th>double</th>
    <td>
      <p>
<pre>
"weight": 123.4567
</pre>
      </p>
    </td>
  </tr><tr id="position">
    <th>position</th>
    <td>
      <p>
      A position is encoded as a <em>latitude;longitude</em> string, valid formats:
      <ol>
        <li>S22.4532;W123.9887 -
          default <a href="search-api-reference.html#geographical-searches">query/result format</a></li>
        <li>N72°23'52;E26°04'22</li>
        <li>N72o20.92;E26o08.54</li>
      </ol>
      Latitude is prefixed by N or S, and longitude by E or W.
      The angular measurement is expressed as degrees with a decimal fraction,
      or as degrees subdivided in minutes and seconds.
      It is also valid to express minutes with a decimal fraction, supporting regular GPS output format.
      Small letter o may be used as a replacement for degrees.
      </p>
      <h3 id="document-api">Document API</h3>
      <p>
      To input a location field using the <a href="../document-api.html">document api</a>,
      use the <em>latitude;longitude</em> string:
<pre>
"location": "N37.401;W121.996"
</pre>
      When output in <em>document api</em>, the field is rendered as:
<pre>
"location": {
    "y": 37401000,
    "x": -121996000
}
</pre>
      The <a href="../geo-search.html#x-y">X/Y coordinates</a> are in millionths of degrees
      </p>
      <h3 id="document-summary">Document summary</h3>
      <p>
      A position field configured as:
<pre>
field location type position { indexing: attribute }
</pre>
      is rendered as:
<pre>
"location.position": {
  "x": -121996000,
  "y": 37401000,
  "latlong": "N37.401000;W121.996000"
}
</pre>
      Adding <em>summary</em>:
<pre>
field location type position { indexing: summary | attribute }
</pre>
      will render it as:
 <pre>
"location": {
  "x": -121996000,
  "y": 37401000
},
"location.position": {
  "x": -121996000,
  "y": 37401000,
  "latlong": "N37.401000;W121.996000"
}
</pre>
      </p><p>
      If the request specifies a <em>position</em>,
      the distance to this position is caluclated and rendered in <em>fieldname.distance</em>.
      Find details in <a href="../geo-search.html">Geo search</a>:
<pre>
"location.position": {
  "x": -121996000,
  "y": 37401000,
  "latlong": "N37.401000;W121.996000"
},
"location.distance": 27488
</pre>
      </p>
    </td>
  </tr><tr id="predicate">
    <th>predicate</th>
    <td>
      <p>
      A <a href="../predicate-fields.html">predicate</a> is a string:
<pre>
"predicate_field": "gender in [Female] and age in [20..30] and pos in [1..4]"
</pre>
      </p>
    </td>
  </tr><tr id="raw">
    <th>raw</th>
    <td>
      <p>
      The content of a <em>raw</em> field is represented as a base64-encoded string:
<pre>
"rawfield": "VW5rbm93biBhcnRpc3QgZnJvbSB0aGUgbW9vbg=="
</pre>
      </p>
    </td>
  </tr><tr id="uri">
    <th>uri</th>
    <td></td>
  </tr><tr id="array">
    <th>array</th>
    <td>
      <p>
      Arrays are represented as JSON arrays.
<pre>
"int_array_field": [
    123,
    456,
    789
]

"string_array_field": [
    "item 1",
    "item 2",
    "item 3"
]
</pre>
    </p>
    </td>
  </tr><tr id="weightedset">
    <th>weightedset</th>
    <td>
      <p>
      Weighted sets are represented as maps where the value is the weight.
      Note, even if the key is not a string as such, it will be represented as a string in the JSON format.
      Default weight is 1.
<pre>
"int_weighted_set": {
    "123": 2,
    "456": 78
}

"string_weighted_set": {
    "item 1": 143,
    "item 2": 6
}
</pre>
      </p>
    </td>
  </tr><tr id="tensor">
    <th>tensor</th>
    <td>
<p>
Feeding a <a href="search-definitions-reference.html#type:tensor">tensor</a> field
is done by specifying the cells of the tensor as follows:
</p>
<pre>
"tensorfield": {
    "cells": [
        { "address": { "x": "a", "y": "b" }, "value": 2.0 },
        { "address": { "x": "c", "y": "d" }, "value": 3.0 }
    ]
}
</pre>
<p>
In this case we have a tensor with two mapped dimensions <em>x</em> and <em>y</em>.
</p><p>
In the next example we have a tensor with two indexed dimensions <em>x</em> and <em>y</em>
representing a 2x2 matrix.
</p>
<pre>
"tensorfield": {
    "cells": [
        { "address": { "x": "0", "y": "0" }, "value": 2.0 },
        { "address": { "x": "0", "y": "1" }, "value": 3.0 },
        { "address": { "x": "1", "y": "0" }, "value": 5.0 },
        { "address": { "x": "1", "y": "1" }, "value": 7.0 }
    ]
}
</pre>

    </td>
  </tr><tr id="struct">
    <th>struct</th>
    <td>
      <p>
      Structs are more or less directly represented as JSON objects, declared by their field name.
<pre>
"mystruct": {
    "intfield": 123,
    "stringfield": "foo"
}
</pre>
      Refer to the reference for restrictions using <a href="search-definitions-reference.html#type:struct">structs</a>.
      </p>
    </td>
  </tr><tr id="map">
    <th>map</th>
    <td>
      <p>
      Maps are represented as JSON dictionaries. The JSON dictionary key must be a string,
      even if the map key type in the search definition is not a string (see below for an example of this).
<pre>
"int_to_string_map": {
    "123": "foo",
    "456": "bar",
    "789": "foobar"
}
</pre>
      Refer to the reference for restrictions using <a href="search-definitions-reference.html#type:map">maps</a>
      </p>
    </td>
  </tr><tr id="annotationreference">
    <th>annotationreference</th>
    <td></td>
  </tr><tr id="reference">
    <th>reference</th>
    <td></td>
  </tr><tr>
  </tr>
</table>



<h2 id="operations">Operations</h2>
<p>
There are three types of operations:
<ul>
    <li>Put - for submitting full document, will insert and overwrite any old document with same ID</li>
    <li>Remove - for removing a document with a given ID</li>
    <li>Update - for updating fields in a document with a specified ID</li>
</ul>
The are two channels for sending document operations, with a slightly different format:
</p>
<table class="table">
    <tr>
        <th width="50%"><a href="../vespa-http-client.html">The Vespa HTTP Client</a></th>
        <th width="50%"><a href="../document-api.html">RESTified Document Operation API</a></th>
    </tr><tr>
        <td>This is a Java API and command line tool to feed asynchronous document operations to Vespa content clusters (for high performance operations)</td>
        <td>This channel accepts one operation per request and is synchronous (not for high performance operations)</td>
    </tr>
</table>

<h3 id="put">Put</h3>
<p>
Writing a document to Vespa looks like:
<table class="table">
        <tr>
            <th width="50%"><a href="../vespa-http-client.html">The Vespa HTTP Client</a></th>
            <th width="50%"> <a href="../document-api.html">RESTified Document Operation API</a></th>
        </tr><tr>
            <td><pre>
{
    "put": "id:music:music::123",
    "fields": {
        "title": "Best of Bob Dylan"
    }
}
</pre></td><td><pre>
http <span style="background-color: yellow;">post</span> /document/v1/music/music/docid/123
{
    "fields": {
        "title": "Best of Bob Dylan"
    }
}
</pre></td>
        </tr>
</table>
Values for the document fields may be set using elements as shown above in the <em>fields</em> object.
In this example, <em>title</em> field is specified in the document type.
See examples using arrays, maps, structs, raw, tensor, and weighted sets below.
</p>



<h3 id="update">Update</h3>
<p>
Updates make changes to documents without submitting the entire document - great for efficiency.
If the document does not exist, Vespa creates creates a new document if
<a href="document-json-update-format.html#create">create if nonexistent</a> is used -
otherwise, returns error.
<table class="table">
    <tr>
        <th width="50%"><a href="../vespa-http-client.html">The Vespa HTTP Client</a></th>
        <th width="50%"><a href="../document-api.html">RESTified Document Operation API</a></th>
    </tr><tr>
        <td><pre>
{
    "update": "id:music:music::123",
    "fields": {
        "title": {
            "assign": "The best of Bob Dylan"
        }
    }
}
</pre></td>
        <td><pre>
http <span style="background-color: yellow;">put</span> /document/v1/music/music/docid/123
{
    "fields": {
        "title": {
            "assign": "The best of Bob Dylan"
        }
    }
}
</pre></td>
    </tr>
</table>
There are three basic operation on <em>field</em> level:
<ul>
  <li><em>Assign</em>: Replace the content of the field</li>
  <li><em>Add</em>: Add a new value to a field (array, weightedset etc)</li>
  <li><em>Remove</em>: Remove a value from a field</li>
</ul>
Find more examples of <a href="document-json-update-format.html">
arithmetic updates and updating composite fields</a>.
</p><p>
<strong>Note:</strong> Messages can be re-sent by Vespa's Message Bus.
This can cause unexpected results for all operations except <em>assign</em> and <em>remove</em>!
If greater consistency is needed, use a <a href="#conditional-updates-test-and-set">conditional update</a> instead.
</p>



<h3 id="remove">Remove</h3>
<table class="table">
    <tr>
        <th width="50%"><a href="../vespa-http-client.html">The Vespa HTTP Client</a></th>
        <th width="50%"> <a href="../document-api.html">RESTified Document Operation API</a></th>
    </tr>
    <tr>
        <td><pre>
{
    "remove": "id:music:music::HitMe"
}
</pre></td>
        <td><pre>
http <span style="background-color: yellow;">delete</span> /document/v1/music/music/docid/HitMe


</pre></td>
    </tr>
</table>



<h3 id="conditional-updates-test-and-set">Conditional execution - test and set</h3>
<p>
An optional <em>condition</em> can be added to operations to specify a <em>test and set</em> condition.
The value of the condition is a <a href="document-select-language.html">document selection</a> encoded as a string.
The <em>put/update/remove</em> operation is only applied if the condition matches an already existing document with that id.
Example: Increment the <em>sales</em> field only if it is already equal to 999:
<table class="table">
    <tr>
        <th width="50%"><a href="../vespa-http-client.html">The Vespa HTTP Client</a></th>
        <th width="50%"> <a href="../document-api.html">RESTified Document Operation API</a></th>
    </tr><tr>
        <td><pre>
{
    "update": "id:music:music::BestOf",
        "condition": "music.sales==999",
        "fields": {
            "sales": {
                "increment": 1
            }
    }
}
</pre></td>
        <td><pre>
http put /document/v1/music/music/docid/BestOf?condition=music.sales=='999'
{
   "fields": {
       "sales": {
           "increment": 1
        }
    }
}

</pre></td>
    </tr>
</table>
<strong>Note:</strong> Use <em>documenttype.fieldname</em> in the condition,
not only <em>fieldname</em>.
</p><p>
<strong>Note:</strong> If the condition is not met, an error is returned.
<strong>ToDo:</strong> There is a discussion whether to change to not return error,
and instead return a <em>condition-not-met</em> in the response.
</p>
