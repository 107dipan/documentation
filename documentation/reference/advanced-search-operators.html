---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Advanced Search Operators"
---

<p>
This document describes the characteristics and differences of Vespa's advanced search operators:
<ul>
    <li><a href="#parallel-wand">Parallel Wand</a></li>
    <li><a href="#dot-product">Dot Product</a></li>
    <li><a href="#weighted-set">Weighted Set</a></li>
    <li><a href="#vespa-wand">Vespa Wand</a></li>
</ul>
A basic description is given for each operator in addition to the following characteristics:
</p>
<ul>
    <li><strong>Field type</strong>: What kind of field types is supported for this operator.</li>
    <li><strong>Query model</strong>: What kind of data is passed down with the query when using this operator.</li>
    <li><strong>Matching</strong>: What is the criteria for a document being a match.</li>
    <li><strong>Ranking</strong>: What kind of ranking is this operator using internally (if any) and
    what is exposed to the ranking framework.</li>
    <li><strong>YQL operator</strong>: How is this operator used in YQL.</li>
    <li><strong>Java Query Item</strong>: How is this operator used in the Java Query API.</li>
</ul>


<h2 id="wand">Wand</h2>
<p>
This document gives an overview of use cases for Wand search operators that are available in Vespa.
All of these operators can be used for efficient top-k retrieval and are based on
<em>Weak AND</em> or <em>Weighted AND</em> as described by Broder et al in
<em>Efficient query evaluation using a two-level retrieval process</em>.
These are operators that scales adaptively from OR to AND.
The available operators are
<a href="#parallel-wand">Parallel Wand</a> and
<a href="#vespa-wand">Vespa Wand</a>.
These operators may be used directly using
<a href="../query-language.html">YQL</a>
or from a Java Searcher plugin.
</p><p>
Use cases for a Wand operator arise when you have many query
terms that you would like to see matched with OR semantics,
but you are only interested in a small number of top hits for the query.
With the normal OR operator the cost rises very quickly with the number of terms,
so five terms inside OR may already be "many":
a simple rule of thumb is that the evaluation cost is proportional to
the number of hits the OR yields.
A Wand operator, in contrast, has a target for the number of hits you want it to produce,
and may throw away hits that are not good enough once it has produced enough hits.
</p><p>
If you are only interested in the best 100 hits (or less) from an OR,
a Wand operator should be a good match.
The basic idea is that after seeing enough hits,
the Wand algorithm will require that a document match more terms (or more relevant terms) in the query.
The operator may go all the way to requiring match on all terms if that gives many hits.
Note that since the behavior is adaptive you will always get at least the target number of hits,
usually many more. Example use cases:
<ul>
  <li>Make recommendations based on user history</li>
  <li>Find similar documents</li>
  <li>Find extra content for a web page that is relevant to the text on the page</li>
</ul>
Note that in the cases above you would extract a large number of words from user history,
from a document, or from some text you are going to display,
and then make a query with all those words as weak criteria,
looking for documents that contain as many of those words as possible,
optionally with extra weight on those words that are considered more important.
</p>



<h2 id="parallel-wand">Parallel Wand</h2>
<p>
Parallel Wand is a search operator that can be used for efficient top-k retrieval.
It implements the "Weak AND"/"Weighted AND" algorithm as described by Broder et al in
"Efficient query evaluation using a two-level retrieval process", and is an operator that scales
adaptively from OR to AND.
</p><p>
Parallel Wand can be used to search for documents where weighted tokens in a field matches a subset of
weighted tokens in the query. At the same time, it internally calculates the dot product
between token weights in the query and the field. Parallel Wand is guaranteed to return the top-k
hits according to its internal dot product rank score.
It also optimizes the performance of using multiple threads per search in the backend.
</p>
<table class="table">
<thead></thead><tbody>
<tr>
    <th>Field type</th>
    <td>Weighted set attribute with fast-search. Note: Also supported for regular attribute or
        index fields, but then with much weaker performance).</td>
</tr>
<tr>
    <th>Query model</th>
    <td>Weighted set with {token, weight} pairs.</td>
</tr>
<tr>
    <th>Matching</th>
    <td>Documents where the weighted set field contains at least one of the tokens in the query and
        where the internal dot product score for this document, is larger than the worst among the
        current top-k best hits. This means that more than top-k documents are matched and returned
        for ranking. It also means that many documents are skipped even they match several tokens
        in the query because the dot product score is too low. This skipping makes Parallel Wand faster
        than Dot Product Operator in some cases.
    </td>
</tr>
<tr>
    <th>Ranking</th>
    <td>Dot product score between the weights of the matched query tokens and field tokens.
        This score is available using <code>rawScore</code> or <code>itemRawScore</code> rank features.
        Note that the top-k best hits are only guaranteed to be returned when using this
        internal score as the final ranking expression.
    </td>
</tr>
<tr>
    <th>YQL operator</th>
    <td><a href="../query-language.html#wand">wand()</a></td>
</tr>
<tr>
    <th>Java Query Item</th>
    <td><a href="http://javadoc.io/page/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WandItem.html">WandItem</a></td>
</tr>
</tbody>
</table>


<p>
Create a Parallel Wand using <a href="../query-language.html#wand">wand() in YQL</a>
or in a Java searcher plugin using the <code>com.yahoo.prelude.query.WandItem</code>.
The field to search must be a weighted set attribute with fast-search.
<p>


<h3 id="example">Example</h3>
<p>
Lets imagine we have an application where we would like to search for popular blogs about cars
and we have the following search definition file.
The weighted set attribute <code>car_types</code> is used to tag an article
with which car types that are discussed in that article,
while the integer attribute <code>popularity</code>
is used to track the static popularity of that article.
We want to search the <code>car_types</code> field using Parallel Wand.
<p><p>
We also have two rank profiles:
<code>dotproductonly</code> uses the raw dot product score that is calculated by Parallel Wand,
while <code>combined_score</code> combines the dot product score with the static popularity score:
<pre>
search article {
  document article {
    field car_types type weightedset&lt;string&gt; {
      indexing: attribute
      attribute: fast-search
    }
    field popularity type int {
      indexing: attribute | summary
    }
  }
  rank-profile dotproductonly {
    first-phase {
      expression: rawScore(car_types)
    }
  }
  rank-profile combined_score {
    first-phase {
      expression: rawScore(car_types) + attribute(popularity)
    }
  }
}
</pre>
</p>


<h3 id="wand-in-yql">wand() in YQL</h3>
<p>
Lets imagine a particular user that is interested in Italian cars, especially sports cars.
This user would mainly like to get blogs discussing Italian sports cars,
but blogs about more usual Italian cars could also be returned.
In the following example we see how to use YQL to create a Parallel Wand for the
<code>car_types</code> field with 25 as the target number of hits to produce.
Notice that the weights for Italian sports cars are higher than for more usual cars.
<pre>
yql=select ignoredfield from ignoredsource where [ {"targetNumHits": 25} ]wand(car_types, {"pagani":400,"lamborghini":300,"maserati":250,"ferrari":150,"lancia":50,"alfa":40,"fiat":30});
</pre>
</p>


<h3 id="com.yahoo.prelude.query.WandItem">com.yahoo.prelude.query.WandItem</h3>
<p>
The same example Parallel Wand can be added in a Java searcher plugin:
<pre>
import com.yahoo.prelude.query.*;
import com.yahoo.search.Query;
import com.yahoo.search.Result;
import com.yahoo.search.query.QueryTree;
import com.yahoo.search.searchchain.Execution;

private Result hardCoded(Query query, Execution execution) {
    WandItem filter = new WandItem("car_types", 25);
    filter.addToken("pagini", 400);
    filter.addToken("lamborghini", 300);
    filter.addToken("maserati", 250);
    filter.addToken("ferrari", 150);
    filter.addToken("lancia", 50);
    filter.addToken("alfa", 40);
    filter.addToken("fiat", 30);
    QueryTree tree = query.getModel().getQueryTree();
    Item oldroot = tree.getRoot();
    AndItem newtop = new AndItem();
    newtop.addItem(oldroot);
    newtop.addItem(filter);
    tree.setRoot(newtop);
    query.trace("added hardcoded filter: ", true, 2);
    return execution.search(query);
}
</pre>
</p>


<h3 id="ranking-notes">Ranking notes</h3>
<p>
Note that when using the <code>default</code> rank profile in this example,
we are guaranteed to get the top-k hits
(according to the raw dot product score of the Parallel Wand)
in the final search result.
This is however not the case when using the <code>combined_score</code> rank profile.
In this case the top-k hits (according to the raw dot product score)
are also returned from the Parallel Wand in the match phase,
but in the ranking phase we also consider the static popularity score
which may alter what is the final top-k hits
according to the expression in the rank profile.
This means that when combining the raw dot product score of the Parallel Wand with something else
(in either a first phase or second phase rank expression),
you must ensure that these rank scores correlate somewhat.
When combining scores like this you also should tune the
<code>targetNumHits</code> used by the Parallel Wand.
</p>


<h3 id="parallel-wand-tuning-target-number-of-hits">Tuning target number of hits</h3>
<p>
When using Parallel Wand via YQL or a Java Searcher plugin, you can specify the target for minimum
number of hits the operator should produce. By default, set <code>targetNumHits</code>
equal to the number of hits you are going to display to the user.
If additional second phase ranking with rerank-count is used,
do not set <code>targetNumHits</code> less than the configured rank-profile's rerank-count.
Note that if you combine Parallel Wand with a ranking expression that does not use its raw score,
the tuning of <code>targetNumHits</code> should follow the guide lines given for Vespa Wand.
</p>


<h3 id="parallel-wand-score-tuning-score-threshold">Tuning Score Threshold</h3>
<p>
You can also specify a score threshold when using Parallel Wand. The internal dot product score for
a document must be larger than <code>scoreThreshold</code> in order to be considered a match.
Default value is 0.0.
</p>



<h2 id="dot-product">Dot Product</h2>
<p>
Dot Product Operator is the brute force equivalent to Parallel Wand.
They are both used to search for documents where weighted tokens in a field matches a subset of
weighted tokens in the query. They also produce the exact same dot product score.
In some simple cases Dot Product Operator is preferable to Parallel Wand.
Take a look at
<a href="../reference/dot-product-search-operator.html">Dot Product Search Operator</a>
reference for more information on these use cases.
</p>
<table class="table">
<thead></thead><tbody>
<tr>
    <th>Field type</th>
    <td>Weighted set attribute with fast-search. Note: Also supported for regular attribute or
        index fields, but then with much weaker performance).</td>
</tr>
<tr>
    <th>Query model</th>
    <td>Weighted set with {token, weight} pairs</td>
</tr>
<tr>
    <th>Matching</th>
    <td>Documents where the weighted set field contains at least one of the tokens in the query.</td>
</tr>
<tr>
    <th>Ranking</th>
    <td>Dot product score between the weights of the matched query tokens and field tokens.
        This score is available using <code>rawScore</code> or <code>itemRawScore</code> rank features.</td>
</tr>
<tr>
    <th>YQL operator</th>
    <td><a href="../query-language.html#dot-product">dotProduct()</a></td>
</tr>
<tr>
    <th>Java Query Item</th>
    <td><a href="http://javadoc.io/page/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/DotProductItem.html">DotProductItem</a></td>
</tr>
</tbody>
</table>
<p>
<code>DotProductItem</code> is a query item available in the search
container that can be used to search for documents matching a subset
of weighted tokens while at the same time calculating the sparse dot
product between token weights in the query item and the corpus.
This is the query operator for which Parallel Wand is an optimization.
</p><p>
You have a collection of weighted tokens produced by an algorithm and
want to perform matching against a corpus containing weighted tokens
produced by another algorithm in order to implement personalized content exploration.
</p><p>
Generally, the use-cases for <em>dot product</em> are the same as
for <a href="#wand">wand</a>.
The <a href="../ranking.html#raw-scores-and-query-item-labeling">raw scores</a> produced by
<em>dot product</em> operators are equivalent to those produced by <em>Parallel Wand</em>.
</p><p>
The difference is that <em>Parallel Wand</em> will perform local
optimizations in order to retrieve the top-k results that would be
returned by the <em>dot product</em> operator.
This optimization will only yield correct results if the overall ranking is equal to the
score produced by the <em>dot product</em> operator itself.
</p><p>
It might make sense to start out using <em>dot product</em> and later
switch to wand if the performance gain outweighs the reduction in
flexibility and correctness.
Also note that benchmarking should be involved in such a switch,
to quantify the possible gain in performance (which might be negative).
</p><p>
Here follows a list of cases where <em>dot product</em> might be
preferable to <em>wand</em> (Better means more correct):
<ul>
  <li>Might be more efficient with few tokens or few total results.</li>
  <li>Works better with arbitrary rank expressions and compound queries.</li>
  <li>Works better with grouping.</li>
  <li>Scales better when partitioning the problem space.</li>
</ul>
<code>DotProductItem</code> is an advanced feature. You may need a
custom searcher to prepare the query. Before that, you will need a
corpus with weighted tokens to be matched. Finally, it is all tied
together by using the score produced by the <em>dot product</em>
operator in a ranking expression.
</p>


<h3>Prepare the Corpus</h3>
<p>
Use a weighted set field in the document to store the tokens.
Use an attribute vector for best performance:
<pre>
field features type weightedset&lt;string&gt; {
    indexing: summary | attribute
    attribute: fast-search
}
</pre>
</p>


<h3>Prepare the Query</h3>
<p>
The query needs to be prepared by a custom searcher or sent
using <a href=" ../query-language.html#dot-product">YQL</a>.
The code below shows the relevant part.
If you use multiple dot products in the same query it is a good idea to label them.
This enables us to use individual dot product scores when ranking results later.
<pre>
Item makeDotProduct(String label, String field, Map&lt;String, Integer&gt; token_map) {
    DotProductItem item = new DotProductItem(field);
    item.setLabel(label);
    for (Map.Entry&lt;String, Integer&gt; entry : token_map.entrySet()) {
        item.addToken(entry.getKey(), entry.getValue());
    }
    return item;
}
</pre>
</p>


<h3>Ranking</h3>
<p>
The <em>dot product</em> operator produces
<a href="../ranking.html#raw-scores-and-query-item-labeling">raw scores</a>
that may be used in a ranking expression.
The simplest approach is to use the sum of all raw scores for the field containing the tokens:
<pre>
rank-profile default {
    first-phase {
        expression: rawScore(features)
    }
}
</pre>
For better control, label each dot product in the query and use their scores individually:
<pre>
rank-profile default {
    first-phase {
        expression: itemRawScore(dp1) + itemRawScore(dp2)
    }
}
</pre>
</p>



<h2 id="weighted-set">Weighted Set</h2>
<p>
Weighted Set Operator is used to search for documents where all tokens in the searched field will
be reverse matched against the tokens of the weighted set in the query. This means that using a Weighted Set
Operator to search a single-value attribute field will have similar semantics to using a normal
term to search a weighted set field. Take a look at
<a href="../reference/weighted-set-term.html">Weighted Set Search Operator</a>
reference for more information on how to use this operator.
</p>
<table class="table">
<thead></thead><tbody>
<tr>
    <th>Field type</th>
    <td>Singlevalue or <a href="../search-definitions.html#multivalue-fields">multivalue</a>
        attribute or index field.
        (Note: Most use cases operates on a single value field).</td>
</tr>
<tr>
    <th>Query model</th>
    <td>Weighted set with {token, weight} pairs.</td>
</tr>
<tr>
    <th>Matching</th>
    <td>Documents where the field contains at least one of the tokens in the query.</td>
</tr>
<tr>
    <th>Ranking</th>
    <td>The operator will act as a single term in the back-end. The query term weight is the weight
        assigned to the operator itself and the match weight is the largest weight among matching
        tokens from the weighted set. This operator does not produce a raw score. Due to better
        ranking and performance we recommend using the Dot Product Operator instead.</td>
</tr>
<tr>
    <th>YQL operator</th>
    <td><a href="../query-language.html#weighted-set">weightedSet()</a></td>
</tr>
<tr>
    <th>Java Query Item</th>
    <td><a href="http://javadoc.io/page/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WeightedSetItem.html">WeightedSetItem</a></td>
</tr>
</tbody>
</table>


<h2 id="vespa-wand">Vespa Wand</h2>
<p>
Vespa Wand is a search operator that also implements the "Weak AND"/"Weighted AND" algorithm.
Unlike Parallel Wand, Vespa Wand can be used to search across several fields of various types,
but it does NOT guarantee to return the top-k best number of hits.
It can however be combined with any ranking expression, but keep in mind that this expression should
correlate with its simple internal ranking score that uses query term weight and inverse document
frequency for matching terms.
</p>
<table class="table">
<thead></thead><tbody>
<tr>
    <th>Field type</th>
    <td>Multiple fields of all types (both attribute and index).</td>
</tr>
<tr>
    <th>Query model</th>
    <td>Arbitrary number of query items searching across different fields.</td>
</tr>
<tr>
    <th>Matching</th>
    <td>Documents that matches at least one of the tokens in the query and where the
        internal operator score for this document is larger than the worst among the current top-k
        best hits. As with Parallel Wand, this means that typically more than top-k documents are matched
        and a lot of documents are skipped.
    </td>
</tr>
<tr>
    <th>Ranking</th>
    <td>Internal ranking score based on query term weight and inverse document frequency for
        matching terms to find the top-k hits. This score is currently not available to the ranking
        framework. Matching terms are exposed to the ranking framework (same as when using AND or OR),
        so an arbitrary ranking expression can be used in combination with this operator.
        Note that the ranking expression used should correlate with this internal ranking score.
        <code>nativeFieldMatch</code> and <code>nativeDotProduct</code> are good starting points.
    </td>
</tr>
<tr>
    <th>YQL operator</th>
    <td><a href="../query-language.html#weak-and">weakAnd()</a></td>
</tr>
<tr>
    <th>Java Query Item</th>
    <td><a href="http://javadoc.io/page/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WeakAndItem.html">WeakAndItem</a></td>
</tr>
</tbody>
</table>


<h3 id="vespa-wand-tuning-target-number-of-hits">Tuning target number of hits</h3>
<p>
When using Vespa Wand via YQL or a Java Searcher plugin you can specify the target for minimum
number of hits the operator should produce. The effect of tuning <code>targetNumHits</code> may not
be very intuitive. To ensure that you get the best hits possible with a Vespa Wand
set the target number somewhat higher than the number of hits displayed to the user;
setting it 10 times higher should be more than enough. The reason for
increasing the target number is that Vespa Wand uses a very simple ranking function internally to
filter away bad hits. If your normal rank expression correlates poorly with this internal filtering
formula, you need to increase the target number. The easiest is probably to use the default number
(100) and see if that gives good results, only tuning if you see a problem. Also note that if your
rank correlates poorly with the filtering criteria, Vespa Wand may not be the appropriate operator.
</p>


<h3 id="vespa-wand-selecting-a-rank-function">Selecting a rank function</h3>
<p>
Anything similar to classic vector model ranking will work well with Vespa Wand. We suggest using
the <code>nativeFieldMatch</code> or <code>nativeDotProduct</code> feature as a starting point.
Note that because Vespa Wand relies on feedback identifying which hits are used for first phase
ranking to increase its threshold for what's considered a good hit, the special <code>unranked</code>
rank profile (which turns off ranking completely) may cause Vespa Wand queries to become slower than
a more normal ranking.
</p>
