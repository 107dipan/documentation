---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Proton"
---

<p>
Proton is Vespa's search core. Proton maintains disk and memory structures for documents.
As the data is dynamic, these structures are periodically optimized.
These jobs temporarily consume resources - make sure the host running Vespa
has sufficient buffer.
</p>


<h2 id="proton-maintenance-jobs">Proton maintenance jobs</h2>
<p>
Tune the jobs in <a href="content/setup-proton-tuning.html">Proton tuning</a>.
<a href="performance/sizing-search.html">Sizing search</a> describes the <em>static</em> proton sizing -
this article details the <em>temporal</em> resource usage for the proton jobs.
</p><p>
There is only one instance of each job at a time - e.g. attributes are flushed in sequence.
When a job is running, its metric is set to 1 - otherwise 0.
Use this to correlate oberserved performance with job runs - see <em>Run metric</em>.
</p><p>
Refer to the implementation of
<a href="https://github.com/vespa-engine/vespa/blob/master/config-model/src/main/java/com/yahoo/vespa/model/admin/monitoring/VespaMetricSet.java">
  performance metrics</a>, see <em>getSearchNodeMetrics()</em>.
Metrics are available at the <a href="reference/metrics-health-format.html">Metrics API</a>.
</p>


<h3 id="attribute-flush">attribute flush</h3>
<p>
Flush an <a href="attributes.html">attribute</a> vector from memory to disk,
based on configuration in the
<a href="content/setup-proton-tuning.html#flushstrategy">flushstrategy</a>.
This controls memory usage and query performance. This also makes proton starts quicker - see
<a href="reference/services-content.html#flush-on-shutdown">flush on shutdown</a>.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      Little - one thread flushes to disk
    </td></tr>
    <tr><th>Memory</th><td>
      Little - some temporal use
    </td></tr>
    <tr><th>Disk</th><td>
      A new file is written to, hence 2x the size of an attribute on disk.
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.attribute_flush</em>
    </td></tr>
    <tr><th>Metric prefix</th><td>
      <em>content.proton.documentdb.[ready|notready].attribute.memory_usage.</em>
    </td></tr>
    <tr><th>Metrics</th><td>
      <em>
        allocated_bytes.average<br/>
        used_bytes.average<br/>
        dead_bytes.average<br/>
        onhold_bytes.average<br/>
      </em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="memory-index-flush">memory index flush</h3>
<p>
Flush a <em>memory index</em> to disk, then trigger <a href="#disk-index-fusion">disk index fusion</a>.
The goal is to shrink memory usage by adding to the disk-backed indices.
Performance characteristics for this flush is similar to indexing.
Note: A high feed rate can cause multiple smaller flushed indices, like
<em>$VESPA_HOME/var/db/vespa/search/cluster.name/n1/documents/doc/0.ready/index/index.flush.102</em>
- see the high index number.
Multiple smaller indices is a symptom of too small memory indices compared to feed rate -
to fix, increase <a href="content/setup-proton-tuning.html#flushstrategy">
flushstrategy &gt; native &gt; component &gt; maxmemorygain</a>.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
       Little - one thread indexes to disk
    </td></tr>
    <tr><th>Memory</th><td>
      Little
    </td></tr>
    <tr><th>Disk</th><td>
      Creates a new disk index, size of the memory index.
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.memory_index_flush</em>
    </td></tr>
    <tr><th>Metric prefix</th><td>
      <em>content.proton.documentdb.index.memory_usage.</em>
    </td></tr>
    <tr><th>Metrics</th><td>
      <em>
        allocated_bytes<br/>
        used_bytes<br/>
        dead_bytes<br/>
        onhold_bytes<br/>
      </em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="disk-index-fusion">disk index fusion</h3>
<p>
Merge the primary disk index with smaller indices generated by
<a href="#memory-index-flush">memory index flush</a> -
triggered by the memory index flush.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      Little - one thread merges indices
    </td></tr>
    <tr><th>Memory</th><td>
      Little
    </td></tr>
    <tr><th>Disk</th><td>
      Creates a new index while serving from the current -
      hence 2x temporal disk usage for the given index.
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.disk_index_fusion</em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="document-store-flush">document store flush</h3>
<p>
Flushes the <a href="document-summaries.html#document-store-memory-usage">document store</a>.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      Little
    </td></tr>
    <tr><th>Memory</th><td>
      Little
    </td></tr>
    <tr><th>Disk</th><td>
      Little
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.document_store_flush</em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="document-store-compaction">document store compaction</h3>
<p>
Defragment and sort <a href="document-summaries.html#document-store">
document store</a> files as documents are updated and deleted,
in order to reduce disk space and speed up
<a href="streaming-search.html">streaming search</a>.
The file is sorted in bucket order on output. Triggered by
<a href="content/setup-proton-tuning.html#summary-store-logstore-maxdiskbloatfactor">
maxdiskbloatfactor</a>.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      Little - one thread reads one files, sorts and writes a new file
    </td></tr>
    <tr><th>Memory</th><td>
      Holds a document summary store file in memory plus memory for sorting the file.
      <strong>Note: This is important on hosts with little memory!</strong>
      Reduce <a href="content/setup-proton-tuning.html#summary-store-logstore-maxfilesize">
      maxfilesize</a> to increase number of files and use less temporal memory for compaction.
    </td></tr>
    <tr><th>Disk</th><td>
      A new file is written while the current is serving, max temporal usage is 2x.
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.document_store_compact</em>
    </td></tr>
    <tr><th>Metric prefix</th><td>
      <em>content.proton.documentdb.[ready|notready|removed].document_store.</em>
    </td></tr>
    <tr><th>Metrics</th><td>
      <em>
        disk_usage.average<br/>
        disk_bloat.average<br/>
        max_bucket_spread.average<br/>
        memory_usage.allocated_bytes.average<br/>
        memory_usage.used_bytes.average<br/>
        memory_usage.dead_bytes.average<br/>
        memory_usage.onhold_bytes.average<br/>
      </em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="bucket-move">bucket move</h3>
<p>
Triggered by nodes going up/down, refer to <a href="elastic-vespa.html">
elastic Vespa</a> and
<a href="reference/services-content.html#searchable-copies">searchable-copies</a>.
Causes documents to be indexed or de-indexed, similar to feeding.
This moves documents in or out of ready/active sub-databases.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      CPU similar to feeding.
      Consumes capacity from the index write thread - hence has feeding impact
    </td></tr>
    <tr><th>Memory</th><td>
      As feeding - the memory index will grow
    </td></tr>
    <tr><th>Disk</th><td>
      As feeding
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.bucket_move</em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="lid-space-compaction">lid-space compaction</h3>
<p>
As <a href="#bucket-move">bucket move</a>, however moves documents <em>within</em> a sub-database.
This is often triggered when a <a href="elastic-vespa.html">cluster grows</a> with more nodes,
documents are redistributed to new nodes and each nodes has less documents -
a LIDspace compaction is hence triggered. This inplace defragments the
<a href="attributes.html#document-meta-store">document meta store</a>.
Resources are freed on a subsequent <a href="#attribute-flush">attribute flush</a>.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      like feeding - add and delete doc
    </td></tr>
    <tr><th>Memory</th><td>
      Little
    </td></tr>
    <tr><th>Disk</th><td>
      0
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.lid_space_compact</em>
    </td></tr>
    <tr><th>Metric prefix</th><td>
      <em>content.proton.documentdb.[ready|notready|removed].lid_space.</em>
    </td></tr>
    <tr><th>Metrics</th><td>
      <em>
        lid_bloat_factor.average<br/>
        lid_fragmentation_factor.average<br/>
      </em>
    </td></tr>
  </tbody>
</table>
</p>



<h3 id="removed-documents-pruning">removed documents pruning</h3>
<p>
Prunes the <em>deleted documents</em> sub-database which keeps IDs for deleted documents.
Default runs once per hour.
<table class="table">
  <thead>
  </thead><tbody>
    <tr><th>CPU</th><td>
      Little
    </td></tr>
    <tr><th>Memory</th><td>
      Little
    </td></tr>
    <tr><th>Disk</th><td>
      Little
    </td></tr>
    <tr><th>Run metric</th><td>
      <em>content.proton.documentdb.job.removed_documents_prune</em>
    </td></tr>
  </tbody>
</table>
</p>
