---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Linguistics in Vespa"
---

<p>
Vespa uses a <em>linguistics</em> module to process text in queries and documents
during indexing and searching. The goal of linguistic processing is to increase
<em>recall</em> (how many documents are matched) without hurting <em>precision</em>
(the relevance of the documents matched) too much. It consists of such operations
as tokenizing text into chunks of known types such as words and punctuation,
normalizing accents and finding the base form of words (stemming or lemmatization).
These operations can be turned on or off per field in a search definition.
</p><p>
Vespa comes with a reasonable linguistics implementation out of the box.
If you want to provide your own, this document explains what you need to do.
</p>



<h2 id="provide-custom-linguistics-implementation">Provide custom linguistics implementation</h2>
<p>
To use a custom linguistics implementation, create an implementation in the application
and configure it as a component in all container clusters doing linguistics processing.
</p>


<h3 id="implement-custom-linguistics">Implement custom linguistics</h3>
<p>
Create an implementation of the
<a href="https://github.com/vespa-engine/vespa/blob/master/linguistics/src/main/java/com/yahoo/language/Linguistics.java">
com.yahoo.language.Linguistics</a> class. Refer to the
<a href="https://github.com/vespa-engine/vespa/blob/master/linguistics/src/main/java/com/yahoo/language/simple/SimpleLinguistics.java">
com.yahoo.language.simple.SimpleLinguistics</a> implementation.
</p>


<h3 id="configure-custom-linguistics">Configure custom linguistics</h3>
<p>To use the custom linguistics implementation, add it as a regular component to all
container clusters which does either query or document processing.
As document processing for indexing is by default done by an autogenerated container cluster
which cannot be configured, specify a container cluster for indexing explicitly.
</p><p>
Below is an example with query and indexing processing in the same cluster
(if using different clusters, make sure to add the same linguistics component to all of them):
<pre>
&lt;services&gt;

  &lt;container version="1.0" id="mycontainer"&gt;
    <span style="background-color: yellow;">&lt;component id="my.linguistics.implementing.Class"/&gt;</span>
    &lt;document-processing/&gt;
    &lt;search/&gt;
    &lt;nodes ...&gt;
  &lt;/container&gt;

  &lt;content version="1.0"&gt;
    &lt;redundancy&gt;1&lt;/redundancy&gt;
    &lt;documents&gt;
      &lt;document type="mydocument" mode="index"/&gt;
      <span style="background-color: yellow;">&lt;document-processing cluster="mycontainer"/&gt;</span>
    &lt;/documents&gt;
    &lt;nodes ...&gt;
  &lt;/content&gt;

&lt;/services&gt;
</pre>



<h2 id="language-handling">Language handling</h2>
<p>
This section describes how language settings are applied in Vespa.
This covers both the <a href="reference/advanced-indexing-language.html#set_language">
set_language</a> indexing expression, as well as the
<a href="reference/search-api-reference.html#model.language">language</a> query parameter.
</p><p>
The single most important thing to note about language handling in Vespa,
is that Vespa does <em>not</em> know the language of a document. Instead,
1) the indexing processor is instructed on a per-field level what language to
use when calling the underlying linguistics library, and
2) the query processor is instructed on a per-query level what language to use.
If no language is explicitly set in a document or a query,
Vespa will run its configured language detector on the available text
(the full content of a document field, or the full <code>query=</code> parameter value).
</p><p>
A document that contains the exact same word as a query might not be recallable
if the language of the document field is detected differently from the query.
Unless the query has explicitly declared a language, this has a high probability of occurring.
</p>


<h3 id="indexing-with-language">Indexing with language</h3>
<p>
The indexing process run by Vespa is nothing more than the sequential execution
of the indexing script of every field in the input document.
At any point, the script may choose to set the language state of the processor
using <a href="reference/advanced-indexing-language.html#set_language">set_language</a>. Example:
<pre>
search book {
    document book {
        field language type string {
            indexing: set_language
        }
        field title type string {
            indexing: index
        }
    }
}
</pre>
Indicating that every document in the input is expected to have its own language.
</p><p>
Because indexing scripts are executed in the order they are given in the search definition,
and because the language state is never reset during the processing of a single document,
all indexed string fields following the <code>language</code> field
will be processed under the rules of that language.
</p><p>
The only thing that changes due to language is the output from
<code>normalize</code> and <code>tokenize</code>.
Now, because <code> indexing: index</code> implies <code>tokenize</code> for string fields,
the field <code>title</code> is affected.
</p><p>
If either <code>normalize</code> or <code>tokenize</code> is invoked prior to <code>set_language</code>,
the language detector is run on the input string.
</p><p>
The net result of this is that by calling <code>set_language</code> inside a document,
you change the terms that end up in a tokenized index.
This means that at query-time, you need to apply the same language settings
before tokenizing the query terms to be able to match what was stored in the index.
This also means that a single index may simultaneously contain terms of multiple languages.
</p><p class="alert alert-success">
Even if a document contains a string field used as input for the
<code>set_language</code> indexing expression,
there is no automation in storing this language in an index.
If you wish to filter by language at some point,
you would have to explicitly save this field as an attribute.
</p>


<h3 id="querying-with-language">Querying with language</h3>
<p>
Now that we understand that the content of an indexed string field are language-agnostic,
it should be clear that one must apply a symmetric tokenization on the query terms
in order to match the content of that field.
And this is exactly what Vespa's query parser does for you.
</p><p>
The query parser subscribes to a configuration file that tells it what fields are indexed strings,
and every query term that targets such a field are run through appropriate tokenization.
The <code> language</code> query parameter is what controls the language state of these calls.
</p><p>
Because an index may simultaneously contain terms in any number of languages,
you might have stemmed variants of one language match the stemmed variants of another.
If you need to work around this, you must store the language of a document in a separate attribute,
and apply a filter against that attribute at query-time.
</p><p>
If no language parameter is given, the language detector is called to process the query string.
The detector is likely to be confused by field names and query syntax,
but it is a best-effort approach.
This matches the language resolution of the index pipeline.
</p><p class="alert alert-success">
By default, there is no knowledge anywhere that captures what
languages are used to generate the content of an index.
The language parameter only affects the transformation of query terms that hit tokenized indexes.
</p>
