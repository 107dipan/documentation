---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Query API"
---

<p>
Use the Vespa Query API to query, rank and organize data.
Simplified, a query has the following components:
<ul>
  <li>Input data</li>
  <li>Ranking and grouping specification</li>
  <li>Results</li>
  <li>Other execution parameters</li>
</ul>
This guide is an introduction to the more important elements in the API -
refer to the <a href="reference/query-api-reference.html">Query API reference</a> for details.
</p>


<h2 id="input">Input</h2>
<p>
Input data is both structured data and unstructured data (the latter called "user input").
Example (URL-decoded for readability):
<pre>{% raw %}
yql=select * from sources * where artist contains "Coldplay" and userInput(@inp);&amp;
inp=paradise&amp;
ranking.features.query(user_profile)={{cat:pop}:0.8,{cat:rock}:0.2,{cat:jazz}:0.1}
{% endraw %}</pre>
The first line is the <a href="query-language.html">YQL</a> query string,
that has both structured input (artist=Coldplay)
and a reference to unstructured user input.
The user input is then given in the second line in the <em>inp</em> parameter.
</p><p>
Separating the structured data from the unstructured relieves the application code from
interpreting and sanitizing the input data - it is essentially a blob.
Vespa can then use heuristics to deduct the user's intention.
User input can also be expressed in the
<a href="reference/simple-query-language-reference.html">simple query language</a> using
the <a href="reference/query-language-reference.html#userquery">userQuery</a> operator.
</p><p>
Finally, input data can also be ranking query features -
here the query feature is called <em>user_profile</em>.
Query features are data, normally valid for this particular instance,
that are used in the subsequent document ranking -
this enables online decision making based on realtime data.
</p>


<h3 id="query-profiles">Query Profiles</h3>
<p>
Use <a href="reference/query-api-reference.html#queryProfile">query profiles</a> to store
query parameters in configuration.
This makes query strings shorter, and makes it easy to modify queries by modifying configuration only.
Use cases are setting query properties for different markets, parameters that do not change, and so on.
Query profiles can be nested, versioned and use inheritance
</p>


<h3 id="geo-filter">Geo Filter</h3>
<p>
Filter by position using latitude and longitude to implement <a href="geo-search.html">geo search</a>.
User a square bounding box, or a position and radius.
<a href="reference/rank-features.html#distanceToPath(name).distance">DistanceToPath</a> is an example
of a <a href="ranking.html">rank function</a> based on closeness.
Using <em>ranking</em> can often improve results instead of geo <em>filtering</em>.
</p>



<h2 id="ranking-and-grouping">Ranking and Grouping</h2>
<p>
<a href="ranking.html">Ranking</a> assigns scores to documents,
and returns documents ordered by score or <a href="reference/sorting.html">sorting</a>.
An application can have multiple
<a href="reference/query-api-reference.html#ranking.profile">rank profiles</a>.
A rank profile is a specification for how to compute a document's score.
Example, query specifies <em>rank_albums</em>, with its schema definition:
<pre>
ranking=rank_albums

rank-profile rank_albums inherits default {
    first-phase {
        expression: sum(query(user_profile) * attribute(category_scores))
    }
}
</pre>

</p><p>
<a href="grouping.html">Grouping</a> is a way to group documents in the result set after ranking.
Example, return max 3 albums per artist,  grouped on artist:
<pre>
| all(group(artist) each(max(3) each(output(summary())) ) );
</pre>
Fields used in grouping (here: artist) must be attributes.
The grouping expression is part of the QYL query string, appended at the end.
</p><p>
Applications can group <em>all</em> documents (select all documents in YQL).
Using hits=0 will return grouping results only.
</p><p>
The above rank profile does not do text ranking -
there are however such profiles built-in.
Text search and ranking is described in more detail in
<a href="text-matching-ranking.html">Text Matching and Ranking</a> -
find information about normalizing, prefix search and linguistics there.
</p>



<h2 id="results">Results</h2>
<p>
All fields are returned in results by default.
To specify a subset of fields, use <a href="/documentation/document-summaries.html">document summaries</a>.
When searching text, having a static abstract of the document in a field, or
using a <a href="/documentation/reference/schema-reference.html#summary">dynamic summary</a>
can both improve the visual relevance of the search, as well as cut bandwidth used.
</p><p>
The default output format is <a href="./reference/default-result-format.html">JSON</a>.
Write a custom <a href="result-rendering.html">Renderer</a> to generate results in other formats.
</p><p>
Read more on <a href="/documentation/jdisc/processing.html">request-response</a> processing -
use this to write code to manipulate results.
</p>



<h2 id="http">HTTP</h2>
<p>
  The <em>host:port</em> endpoint is the <a href="querying-vespa.html">Container</a>.
  The general form of a GET-request is:
<pre>
http://host:port/search/?param1=value1&amp;param2=value2&amp;...
</pre>
  The general form of request with JSON-queries is:
<pre>
{
  param1 : value1,
  param2 : value2,
  ...
}
</pre>
  The format is based on the <a href="reference/query-api-reference.html">Query API reference</a>,
  and has been converted from the <em>flat</em> dot notation to a <em>nested</em> JSON-structure.
  <ul>
    <li>
      The request-method must be POST and the <em>Content-Type</em> must be <em>"application/json"</em>.
    </li><li>
        Feel free to use the GUI for building queries at <a href="http://localhost:8080/querybuilder/">http://localhost:8080/querybuilder/</a> (with Vespa running) which can help you build queries, with e.g. autocompletion of YQL, pasting of already built queries and conversion of JSON- to URL-queries
    </li>
  </ul>
  Example:
<pre>
{
  "yql" : "select * from sources * where default contains \"bad\";",
  "offset" : 5,
  "ranking" : {
    "matchPhase" : {
      "ascending" : true,
      "maxHits" : 15
    },
  },
  "presentation" : {
    "bolding" : false,
    "format" : "json"
  }
}
</pre>
  The only mandatory parameter is <em>yql</em>.
</p><p>
  Use GET or POST - Parameters can either be sent as GET-parameters or posted as JSON, these are equivalent:
<pre>
$ curl -H "Content-Type: application/json" \
    --data '{"yql" : "select * from sources * where default contains \"bad\";"}' \
    http://localhost:8080/search/

$ curl http://localhost:8080/search/?yql=select+%2A+from+sources+%2A+where+default+contains+%22bad%22%3B
</pre>
  <strong>Note: It is possible to write security filters that block GET and POST requests differently.
    This can block POSTed queries.</strong>
</p><p>
  The Search Container uses Jetty for HTTP.
  Configure the <a href="reference/services-http.html#server">http server</a> -
  e.g. set <em>requestHeaderSize</em> to configure URL length (including headers):
<pre>
&lt;container version="1.0"&gt;
  &lt;http&gt;
    &lt;server port="8080" id="myserver"&gt;
      &lt;config name="jdisc.http.connector"&gt;
        &lt;requestHeaderSize&gt;32768&lt;/requestHeaderSize&gt;
      &lt;/config&gt;
    &lt;/server&gt;
  &lt;/http&gt;
&lt;/container&gt;
</pre>
  HTTP keepalive is supported.
</p><p>
  Values must be encoded according to standard URL encoding.
  Thus, space is encoded as +, + as %2b and so on -
  see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>.
</p><p>
HTTP status codes are found in the
<a href="reference/query-api-reference.html#http-status-codes">Query API reference</a>.
Also see <a href="https://stackoverflow.com/questions/54340386/how-should-i-customize-my-search-result-in-vespa/54344429#54344429">
Stack Overflow question</a>.
</p>



<h2 id="other">Other</h2>
<p>
Below is a list of query parameters to control aspects of queries -
refer to the <a href="reference/query-api-reference.html">Query API reference</a>
for the full list.
<table class="table">
  <thead></thead><tbody>
    </tr><tr>
      <th>searchChain</th>
      <td>
        Use <a href="reference/query-api-reference.html#searchChain">search chains</a>
        to implement query processing.
        Set <em>&amp;tracelevel=2</em> to inspect the search chain components.
        Refer to <a href="chained-components.html">chained components</a>
      </td>
    </tr><tr>
      <th>sources</th>
      <td>
        An application can have multiple content clusters - Vespa searches in all by default.
        <a href="federation.html">Federation</a> controls how to query the clusters,
        <a href="reference/query-api-reference.html#model.sources">sources</a> names the clusters
      </td>
    </tr>
  </tbody>
</table>
</p>



<h2 id="troubleshooting">Troubleshooting</h2>
<p>
If Vespa cannot generate a valid search expression from the query string,
it will issue the error message <em>Null query</em>.
To troubleshoot, add <a href="reference/query-api-reference.html#tracelevel">&amp;tracelevel=2</a> to the request.
A missing <em>yql</em> parameter will also lead to this error message.
</p>


<h3 id="query-tracing">Query tracing</h3>
<p>
Use <a href="reference/default-result-format.html#trace">query tracing</a> to debug query execution.
Enable by using <a href="reference/query-api-reference.html#tracelevel">tracelevel=1</a> (or higher).
Add <a href="reference/query-api-reference.html#trace.timestamps">trace.timestamps=true</a>
for timing info for every searcher invoked. Example:
<pre>
http://localhost:8080/search/?yql=select+%2A+from+sources+%2A+where+default+contains+%22hi%22%3B&amp;tracelevel=6&amp;trace.timestamps=true

{
    trace: {
        children: [
            {
            message: "No query profile is used"
            },
            {
            message: "Resolved properties: tracelevel=6 (value from request) yql=select * from sources * where default contains "hi"; (value from request) trace.timestamps=true (value from request) "
            },
            {
            message: "Invoking chain 'vespa' [com.yahoo.prelude.statistics.StatisticsSearcher@native -> com.yahoo.prelude.querytransform.PhrasingSearcher@vespa -> ... -> federation@native]"
            },
            {
            children: [
                {
                timestamp: 0,
                message: "Invoke searcher 'com.yahoo.prelude.statistics.StatisticsSearcher in native'"
                },
                {
                timestamp: 14,
                message: "com.yahoo.prelude.statistics.StatisticsSearcher in native Dependencies{provides=[StatisticsSearcher, com.yahoo.prelude.statistics.StatisticsSearcher], before=[rawQuery], after=[]}"
                },
</pre>
In own code, use
<a href="https://javadoc.io/page/com.yahoo.vespa/container-search/latest/com/yahoo/search/Query.html">Query.trace</a>
to add trace output.
</p>
