---
# Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Text Matching and Ranking"
---

<p>
Refer to the <a href="ranking.html">ranking</a> introduction for Vespa ranking.
See the <a href="tutorials/text-search.html">text search</a> and
<a href="tutorials/text-search-ml.html">test search through ML</a> tutorials.
Also relevant is the guide for
<a href="semantic-qa-retrieval.html">Semantic Retrieval for Question Answering Applications</a>.
</p><p>
Refer to <a href="linguistics.html">Linguistics</a> for details.
</p>


<h2 id="matching">Matching</h2>
<p>
Use the <a href="vespa-quick-start.html">quick start</a> guide and stop after the feeding step.
Make sure to feed all 5 albums with titles:
<pre>
$ cat sample-apps/album-recommendation-selfhosted/src/test/resources/*.json | grep album
        "album": "A Head Full of Dreams",
        "album": "Hardwired...To Self-Destruct",
        "album": "Liebe ist für alle da",
        "album": "Love Is Here To Stay",
        "album": "When We All Fall Asleep, Where Do We Go?",
</pre>
Flush and dump index data (file name can change for subsequent flushes):
<pre>
$ docker exec vespa bash -c '/opt/vespa/bin/vespa-proton-cmd --local triggerFlush &amp;&amp; \
    /opt/vespa/bin/<a href="reference/vespa-cmdline-tools.html#vespa-index-inspect">vespa-index-inspect</a> dumpwords \
    --indexdir /opt/vespa/var/db/vespa/search/cluster.music/n0/documents/music/0.ready/index/index.flush.1 \
    --field album'

a	1
all	2
asleep	1
da	1
destruct	1
do	1
dream	1
fall	1
full	1
fur	1
go	1
hardwire	1
head	1
here	1
is	1
ist	1
lieb	1
love	1
of	1
self	1
stay	1
to	2
we	1
when	1
where	1
</pre>
Observe the <a href="linguistics.html">linguistic transformations</a> to the data before indexed:
<table class="table">
<tr>
  <td>Hardwired...To &#x2192; Hardwired To</td><td>Tokenization - split terms on non-characters</td>
</tr><tr>
  <td>Head &#x2192; head</td><td>Lowercasing</td>
</tr><tr>
  <td>für &#x2192; fur</td><td>Normalizing</td>
</tr><tr>
  <td>dreams &#x2192; dream</td><td>Stemming</td>
</tr>
</table>
The <em>album</em> field has <a href="reference/schema-reference.html#indexing">index</a> mode.
For text fields, this enables the transformations above, and increases recall.
Text search use cases normally uses this mode.
</p><p>
Then, change string fields from <em>index</em> to <em>attribute</em>
in <a href="https://github.com/vespa-engine/sample-apps/blob/master/album-recommendation-selfhosted/src/main/application/schemas/music.sd">
src/main/application/schemas/music.sd</a>:
<pre>
         field artist type string {
-            indexing: summary | index
+            indexing: summary | attribute
         }

         field album type string {
-            indexing: summary | index
+            indexing: summary | attribute
         }
</pre>
Run the tutorial again using the new schema, this time dumping data from the attributes
(snapshot name can change with flushes):
<pre>
$ docker exec vespa bash -c '/opt/vespa/bin/vespa-proton-cmd --local triggerFlush &amp;&amp; \
  /opt/vespa/bin/<a href="reference/vespa-cmdline-tools.html#vespa-attribute-inspect">vespa-attribute-inspect</a> -p \
  /opt/vespa/var/db/vespa/search/cluster.music/n0/documents/music/0.ready/attribute/album/snapshot-10/album &amp;&amp; \
  cat /opt/vespa/var/db/vespa/search/cluster.music/n0/documents/music/0.ready/attribute/album/snapshot-10/album.out'

doc 0: valueCount(1)
    0: []
doc 1: valueCount(1)
    0: [A Head Full of Dreams]
doc 2: valueCount(1)
    0: [Love Is Here To Stay]
doc 3: valueCount(1)
    0: [Hardwired...To Self-Destruct]
doc 4: valueCount(1)
    0: [Liebe ist für alle da]
doc 5: valueCount(1)
    0: [When We All Fall Asleep, Where Do We Go?]
</pre>
</p>
The most important observation is that the strings are added as-is to attributes.
Hence, values must be matched <span style="text-decoration: underline">exactly</span>,
including whitespace, with some exceptions:
<ul>
  <li>When searching attributes, both query terms and attribute data are lowercased</li>
</ul>
</p>


<h3 id="query-trace">Query Trace</h3>
<p>
Adding <a href="reference/query-api-reference.html#tracelevel">tracelevel=2</a>
gives insight when testing queries - example attribute lowercasing:
<pre>
http://localhost:8080/search/?ranking=rank_albums&yql=select%20%2A%20from%20sources%20%2A%20where%20album%20contains%20%22Liebe+ist+f%C3%BCr+alle+da%22%3B&tracelevel=2

http://localhost:8080/search/?ranking=rank_albums&yql=select%20%2A%20from%20sources%20%2A%20where%20album%20contains%20%22liebe+ist+f%C3%BCr+alle+da%22%3B&tracelevel=2
</pre>
Also try query tracing to see how query parsing changes with
<em>index</em> and <em>attribute</em> indexing modes.
</p>


<!-- ToDo: prefix/substring -->
<!-- ToDo: streaming search note -->
<!-- ToDo: refer to
  https://docs.vespa.ai/documentation/reference/schema-reference.html#match
  https://docs.vespa.ai/documentation/reference/schema-reference.html#indexing
  and write some guidance -->


<h2 id="ranking">Ranking</h2>
<p>
The default ranking is <code>nativeRank</code> in the first phase and no second phase re-ranking.
The <code>nativeRank</code> is a feature which gives a reasonably good rank score,
while being fast enough to be suitable for first phase ranking.
See the <a href="reference/nativerank.html">native rank reference</a> and
<a href="nativerank.html">native rank introduction</a> for more information.
</p></p>
An alternative to <code>nativeRank</code> is using the
<a href="reference/bm25.html">BM25</a> rank feature.
</p><p>
If the expression is written manually, it might be most convenient to
stick with using the <code>fieldMatch(<em>name</em>)</code> feature for each field.
This feature combines the more basic fieldMatch features in a reasonable way.
A good way to combine the fieldMatch score of each field is to use a weighted average as explained above.
Another way is to combine the field match scores
using the <code>fieldMatch(<em>name</em>).weight/significance/importance</code> features
which takes term weight or rareness or both into account
and allows a normalized score to be produced by simply summing the product of this feature
and any other normalized per-field score for each field.
In addition, some attribute value(s) must usually be included
to determine the a priori quality of each document.
</p><p>
For example, assuming the title field is more important than the body field,
create a ranking expression which gives more weight to that field, as in the example above.
Vespa contains some built-in convenience support for this -
weights can be set in the individual fields by <code>weight: &lt;number&gt;</code>
and the feature <code>match</code> can be used to get a weighted average
of the fieldMatch scores of each field.
The overall ranking expression might contain other ranking dimensions than just text match,
like freshness, the quality of the document, or any other property of the document or query.
</p>


<h3 id="weight-significance-and-connectedness">Weight, significance and connectedness</h3>
<p>
Modify the values of the match features from the query
by sending weight, significance and connectedness with the query:
<table class="table">
  <thead></thead><tbody>
    <tr><th>Weight</th><td><p>
      Set query term weight.
      Example: <code>... where (title contains ([{"weight":200}]"heads") AND title contains "tails")</code>
      specifies that <code>heads</code> is twice as important for the final rank score than <code>tails</code>
      (the default weight is 100).
      </p><p>
      Weight is used in <code><a href="reference/rank-features.html#fieldMatch(name).weight">
      fieldMatch(<em>name</em>).weight</a></code>, which can be multiplied with
      <code><a href="reference/rank-features.html#fieldMatch(name)">
      fieldMatch(<em>name</em>)</a></code> to yield a weighted score for the field,
      and in <code><a href="reference/rank-features.html#fieldMatch(name).weightedOccurrence">
      fieldMatch(<em>name</em>).weightedOccurrence</a></code>
      to get a occurrence score which is higher if higher weighted terms occurs most.
      Configure static field weights in the
      <a href="reference/schema-reference.html#weight">schema</a>.</p></td>
    </tr><tr><th>Significance</th><td><p>
      How rare a particular term is in the corpus or the language.
      This is sometimes valuable information because if a document matches a rare word,
      it might mean the document is more important than one which matches a common word.
      Significance is calculated automatically by Vespa during indexing,
      but can also be overridden by setting the significance values on the query terms
      in a <a href="searcher-development.html">Searcher component</a>.
      Significance is accessible in
      <code><a href="reference/rank-features.html#fieldMatch(name).significance">
      fieldMatch(<em>name</em>).significance</a></code>, which can be used the same way as weight.
      Weight and significance are also averaged into
      <code><a href="reference/rank-features.html#fieldMatch(name).importance">
      fieldMatch(<em>name</em>).importance</a></code> for convenience.</p></td>
    </tr><tr><th>Connectedness</th><td><p>
      Signify the degree of connection between adjacent terms in the query.
      For example, the query <code>new york newspaper</code> should have a higher connectedness
      between the terms "new" and "york" than between "york" and "newspaper" to rank documents higher
      if they contain "new york" as a phrase.
      Term connectedness is taken into account by
      <code><a href="reference/rank-features.html#fieldMatch(name).proximity">
      fieldMatch(<em>name</em>).proximity</a></code>,
      which is also an important contribution to
      <code><a href="reference/rank-features.html#fieldMatch(name)">fieldMatch(<em>name</em>)</a></code>.
      Connectedness is a normalized value which is 0.1 by default.
      It must be set by a custom Searcher,
      looking up connectivity information from somewhere - there is no query syntax for it.</p></td>
    </tr>
  </tbody>
</table>
</p>



