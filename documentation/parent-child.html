---
# Copyright 2019 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Parent/Child"
---

<p>
Using document references, documents can have parent/child relationships.
Use this to join data - features
<ul>
  <li>simplify document operations - one write to update one value</li>
  <li>no de-normalization needed - simplifies data updates and atomic update into all children</li>
  <li>search parent documents only, as well as all documents</li>
</ul>
An alternative to parent documents is using arrays of struct fields - this guide covers both.
</p><p>
Common use cases are applications with structured data like commerce (e.g. products with multiple sellers),
advertising (advertisers with campaigns with ads, that have budgets that need realtime updates).
</p><p>
High-level overview of documents, imported fields and array fields:
</p><p>
<img src="img/parent-child-1.svg" height="500" width="500" />
</p>

<p>
Model parent-child relationships by using
<a href="reference/search-definitions-reference.html#type:reference">references</a>
to <a href="reference/services-content.html#document">global documents</a>.
Using a reference, fields can be
<a href="reference/search-definitions-reference.html#import-field">imported</a>
from parent types into the child's search definition and used for matching, ranking, grouping and sorting.
</p>
<p>
When using parent-child relationships,
data does not have to be denormalized as fields from parents are imported into children.
Use this to update parent fields to limit number of updates if a field's value is shared beween many documents.
This also limits the resources (memory / disk) required to store and handle documents on content nodes.
</p>


<h2 id="parent-documents">Parent documents</h2>
<p>
Documents can have references to parent documents (like foreign keys in a relational database),
in multiple levels - parents can have parents (grandparents).
Parent documents must be <a href="reference/services-content.html#document.global">global documents</a>.
A reference is a string <a href="attributes.html">attribute</a> with the parent's document ID as value.
References are hence weak:
<ul>
  <li>no cascade delete</li>
  <li>a referenced document can be non-existent - imported fields do not have values in this case</li>
</ul>
</p><p>
Documents can import field values into own fields from parent documents.

Some restrictions on grandparent fields and complex types, ref <a href="https://github.com/vespa-engine/vespa/issues/7930">#7930</a>
</p><p>
At cluster changes, global documents are merged to new nodes before regular documents.
A content node is not serving queries before <span style="text-decoration: underline;">all</span>
global documents are synchronized - refer to <a href="elastic-vespa.html">elastic Vespa</a> for details.
</p><p>

</p>


<h3 id="performance">Performance</h3>
<p>
As parent documents are global,
a PUT or UPDATE will execute on <span style="text-decoration: underline;">all</span> content nodes.
Node capacity will limit the number of such documents -
there should normally be an order of magnitude fewer parent documents than child documents.
</p><p>
Memory usage grows accordingly. A global document is otherwise equal to a regular document,
but each content node must be sized to hold all global documents plus its share of regular documents.
</p><p>
NOTE: Reference and imported fields are not supported in streaming mode.
</p><p>
size of a reference
</p><p>
A document can have references to multiple parents - the parents can be of same or different types.
</p><p>
query performance - references fields add an indirection
</p><p>
</p><p>
</p><p>
</p>



<h2 id="multivalue-fields">Multivalue fields</h2>
<p>
A document can have fields that are arrays of structs.
Structs and documents are similar - a set of field name/value pairs.
One-to-many mappings can hence be implemented this way, as an alternative to using parent/child.
</p><p>
<a href="query-language.html#same-element">sameElement()</a> is a useful query operator
to restrict matches to same struct element.
</p><p>
fieldpath to update?
</p><p>
</p><p>
</p><p>
</p><p>
</p>



<h2 id="example">Example</h2>
<pre>
search advertiser {
  document advertiser {
    field name type string {
      indexing : attribute
    }
  }
}
</pre>
<pre>
[
  { "put": "id:test:advertiser::cool", "fields": { "name": "cool" } }
]
</pre>

<pre>
search campaign {
  document campaign {
    field advertiser_ref type <span style="background-color: yellow">reference&lt;advertiser&gt;</span> {
      indexing: attribute
    }
    field budget type int {
      indexing : attribute
    }
  }
  <span style="background-color: yellow">import field advertiser_ref.name as advertiser_name</span> {}
}
</pre>
<pre>
[
  { "put": "id:test:campaign::thebest", "fields": {
      "advertiser_ref": "id:test:advertiser::cool",
      "budget": 20 }
  },
  { "put": "id:test:campaign::nextbest", "fields": {
      "advertiser_ref": "id:test:advertiser::cool",
      "budget": 10 }
  }
]
</pre>
<pre>
search salesperson {
  document salesperson {
    field name type string {
      indexing: attribute
    }
  }
}
</pre>
<pre>
[
  { "put": "id:test:salesperson::johndoe", "fields": { "name": "John Doe" } }
]
</pre>
<pre>
search ad {
  document ad {
    field campaign_ref type <span style="background-color: yellow">reference&lt;campaign&gt;</span> {
      indexing: attribute
    }
    field other_campaign_ref type reference&lt;campaign&gt; {
      indexing: attribute
    }
    field salesperson_ref type reference&lt;salesperson&gt; {
      indexing: attribute
    }
  }

  <span style="background-color: yellow">import field campaign_ref.budget as budget</span> {}
  import field salesperson_ref.name as salesperson_name {}
  import field campaign_ref.advertiser_name as advertiser_name {}

  document-summary my_summary {
    summary budget type int {}
    summary salesperson_name type string {}
    summary advertiser_name type string {}
  }
}
</pre>
<pre>
[
  { "put": "id:test:ad::1", "fields": {
      "campaign_ref": "id:test:campaign::thebest",
      "other_campaign_ref": "id:test:campaign::nextbest",
      "salesperson_ref": "id:test:salesperson::johndoe" }
  }
]
</pre>
<p>
Document type <em>ad</em> has two references to <em>campaign</em>
(via <em>campaign_ref</em> and <em>other_campaign_ref</em>)
and one reference to <em>salesperson</em> (via <em>salesperson_ref</em>).
The <em>budget</em> field from <em>campaign</em> is imported into the <em>ad</em> search definition
(via <em>campaign_ref</em>) and given the name <em>budget</em>.
Similarly, the <em>name</em> of <em>salesperson</em> is imported as <em>salesperson_name</em>.
Document type <em>campaign</em> has a reference to <em>advertiser</em>
and imports the field <em>name</em> as <em>advertiser_name</em>.
This is also imported into <em>ad</em> via <em>campaign_ref</em> from its grandparent <em>advertiser</em>.
To use the imported fields in summary, define a document summary <em>my_summary</em> containing these fields.
</p>
