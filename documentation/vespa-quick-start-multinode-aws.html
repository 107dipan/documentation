---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Multi-Node Quick Start: Install and run Vespa on AWS EC2"
---

<p>Prerequisites:
<ul>
  <li>An AWS account </li>
  <li>Familiarity with <a href="vespa-quick-start-centos.html">setting up a single-node system on CentOS</a>
</ul>
This guide explains how to set up a multinode Vespa system on <a href="https://aws.amazon.com/ec2">AWS EC2</a> instances.
The tasks involved are similar to setting up a single-node system on CentOS.
Also read <a href="vespa-quick-start-multinode-aws-ecs.html">using ECS to set up a multinode docker based system</a>.
</p>



<h2 id="launch-instances">Launch instances</h2>
<ol>
	<li>
    <strong>Configure an AWS security group</strong>
    <p>
    Configure an <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">
    AWS security group</a> which will limit access to the installation
    and allow our launced EC2 instances to talk to each other without restrictions.
    Refer to <a href="securing-your-vespa-installation.html">securing a Vespa installation</a>.
	  <ul>
      <li>
        Allow access to inbound TCP port <samp>8080</samp> (feed &amp; search port) from your source IP range
      </li><li>
        Allow access to inbound for all TCP traffic on port range <samp>0 - 65535</samp> for members of the security group.
        This is done by first creating the security group with basic access from your source IP range
        to port <samp>8080</samp> for search and feed.
        Once saved, edit it with an additional inbound rule which uses the security group id as source
      </li><li>
        The security group must allow inbound ssh connections
      </li>
    </ul>
    </p>
	</li><li>
    <strong>Chose Amazon Machine image (AMI)</strong>
    <p>
    Chose Linux/Unix, CentOS 7 | 64-bit Amazon Machine Image (AMI) as Amazon Machine Image (AMI) -
    there are both commercial AMI's and Community based AMI's available
    </p>
	</li><li>
    <strong>Chose instance type and launch 4 instances</strong>
    <p>
    <em>t2.medium</em> is suffucient for this guide -
    for production setups see the <a href="performance/sizing-search.html">sizing guide</a>.</p>
	</li>
</ol>



<h2 id="install-and-start">Install and start</h2>
<p>
In this example uses <samp>ip-172-1-1-1.us-east-2.compute.internal</samp>
as the administration node and all commands below are run from that host.
First log on to this host using the Public DNS record name
(E.g <samp>ec2-18-1-1-1.us-east-2.compute.amazonaws.com</samp>).
Using ssh agent forwarding will simplifies, given your aws identify key file <samp>my-aws-key.pem</samp>
and assuming the AMI uses <samp>centos</samp> as login user:
<pre>
$ ssh-add my-aws-key.pem
$ ssh -A centos@ec2-18-1-1-1.us-east-2.compute.amazonaws.com
</pre>
Inside the AWS EC2 cloud, boostrap the system:
<ol>
  <li>
    Create <samp>hosts.txt</samp> with the EC2 instances allocated above - example:
<pre>
$ cat hosts.txt
ip-172-1-1-1.us-east-2.compute.internal
ip-172-1-1-2.us-east-2.compute.internal
ip-172-1-1-3.us-east-2.compute.internal
ip-172-1-1-4.us-east-2.compute.internal
</pre>
  </li><li>
    Download and distribute the aws bootstrap script:
<pre>
$ curl -s https://raw.githubusercontent.com/vespa-engine/sample-apps/bergum/aws-bootstrap/aws_bootstrap.sh \
  > aws_bootstrap.sh
$ for host in $(cat hosts.txt); do \
  scp -o StrictHostKeyChecking=no aws_bootstrap.sh $host:.; done
</pre>
  </li><li>
    The bootstrap script installs vespa and git, does basic system configuration
    and starts vespa and the configuration server on the admin node.
    The script expects a single hostname as argument
    which should be the name of the administration/configuration server,
    in this case <samp>ip-172-1-1-1.us-east-2.compute.internal</samp>.
    The last step might take some time to complete:
<pre>
$ for host in $(cat hosts.txt); do \
  ssh -f $host "sudo bash aws_bootstrap.sh ip-172-1-1-1.us-east-2.compute.internal"; done
</pre>
  </li>
</ol>



<h2 id="configure-and-deploy">Configure and deploy</h2>
<p>
The instances now run, next step is to configure Vespa using an example
<a href="cloudconfig/application-packages.html">application package</a> - on the admin node, do:
</p>
<ol>
  <li>
    <p>
    <strong>Configure the multi-node application:</strong>
    </p><p>
    An example application is found at
    <a href="https://github.com/vespa-engine/sample-apps/tree/master/basic-search">github.com/vespa-engine/sample-apps/basic-search</a>.
<pre>
$ export VESPA_HOME=/opt/vespa; export PATH=$PATH:$VESPA_HOME/bin
$ git clone https://github.com/vespa-engine/sample-apps.git 
$ cd sample-apps/basic-search
</pre>
    Modify <samp>src/main/application/hosts.xml</samp> (replace hostnames):
<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!-- Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root. --&gt;
&lt;hosts&gt;
  &lt;host name="ip-172-1-1-1.us-east-2.compute.internal"&gt;
    &lt;alias&gt;admin0&lt;/alias&gt;
    &lt;alias&gt;stateless0&lt;/alias&gt;
  &lt;/host&gt;

  &lt;host name="ip-172-1-1-2.us-east-2.compute.internal"&gt;
    &lt;alias&gt;stateless1&lt;/alias&gt;
  &lt;/host&gt;

  &lt;host name="ip-172-1-1-3.us-east-2.compute.internal"&gt;
    &lt;alias&gt;content0&lt;/alias&gt;
  &lt;/host&gt;

  &lt;host name="ip-172-1-1-4.us-east-2.compute.internal"&gt;
    &lt;alias&gt;content1&lt;/alias&gt;
  &lt;/host&gt;
&lt;/hosts&gt;
</pre>
    <a href="reference/hosts.html"><samp>hosts.xml</samp></a> describes the hosts to deploy vespa on.
    Each node has a set of role names using aliases to be used in <samp>services.xml</samp>.
    Configure which services should run where in <samp>src/main/application/services.xml</samp>:
<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!-- Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root. --&gt;
&lt;services version="1.0"&gt;
  &lt;admin version="2.0"&gt;
    &lt;adminserver hostalias="admin0"/&gt;
    &lt;configservers&gt;
      &lt;configserver hostalias="admin0"/&gt;
    &lt;/configservers&gt;
  &lt;/admin&gt;

  &lt;container version="1.0" id="default"&gt;
    &lt;document-api/&gt;
    &lt;search/&gt;
    &lt;nodes&gt;
      &lt;node hostalias="stateless0"/&gt;
      &lt;node hostalias="stateless1"/&gt;
    &lt;/nodes&gt;
  &lt;/container&gt;

  &lt;content id="music" version="1.0"&gt;
    &lt;redundancy&gt;2&lt;/redundancy&gt;
    &lt;documents&gt;
      &lt;document type="music" mode="index"/&gt;
    &lt;/documents&gt;
    &lt;nodes&gt;
      &lt;node hostalias="content0" distribution-key="0"/&gt;
      &lt;node hostalias="content1" distribution-key="1"/&gt;
    &lt;/nodes&gt;
  &lt;/content&gt;
&lt;/services&gt;
</pre>
    <a href="reference/services.html"><samp>services.xml</samp></a> maps services to node aliases -
    in this example one <samp>configserver</samp>, two stateless container search/feed
    and two content nodes storing data with a redundancy of 2.
    </p>
  </li><li>
    <p><strong>Start the config server:</strong>
<pre>
$ $VESPA_HOME/bin/vespa-start-configserver
</pre>
    </p>
  </li><li>
    <p><strong>Deploy the application:</strong></p>
    <p>
<pre>
$ vespa-deploy prepare src/main/application &amp;&amp; vespa-deploy activate
</pre>
    The Vespa instances subscribes to configuration and once the application is deployed
    the set of services configured will start - no need to re-start Vespa or the config server.
    When changing the application, just deploy again and the system will make the change.
    </p>
  </li><li>
    <p><strong>Inspect &amp; Verify</strong>:</p>
    <p>
    Inspect the system state using <a href="content/admin-states.html"><samp>vespa-get-cluster-state</samp></a>,
    making sure services are 'up':
<pre>
$ vespa-get-cluster-state
Cluster music:
music/distributor/0: up
music/distributor/1: up
music/storage/0: up
music/storage/1: up
</pre>
    </p>
  </li>
</ol>



<h2 id="feed-documents-and-search">Feed documents and search</h2>
<ol>
  <li>
    <p><strong>Feed documents:</strong></p>
    <p>
    Feed sample documents:
<pre>
java -jar $VESPA_HOME/lib/jars/vespa-http-client-jar-with-dependencies.jar \
  --file music-data-feed.json --host localhost --port 8080
</pre>
    </p>
  </li><li>
    <p><strong>Run queries:</strong></p>
    <p>Replace with <samp>stateless</samp> hosts in <samp>hosts.xml</samp>:
<pre>
$ curl -s http://stateless0:8080/search/?query=bad | python -m json.tool
$ curl -s http://stateless1:8080/search/?query=bad | python -m json.tool
</pre>
    Read more in the <a href="search-api.html">Search API</a>
    </p>
  </li><li>
    <p><strong>(Optional) Configure AWS EC2 Load Balancer:</strong></p>
    <p>
    Configure a load balancer using the same security group
    which forwards requests to the two serving containers listening on port 8080 mentioned above,
    using </em>/status.html</em> as health check.
    Access both endpoints through a DNS A record,
    e.g <em>vespa-multinode-12345678910.us-east-2.elb.amazonaws.com:8080</em>.
    </p>
  </li>
</ol>



<h2 id="next-steps">Next Steps</h2>
<ul>
  <li>
    Try the <a href="tutorials/blog-search.html">Blog search and recommendation tutorial</a>
    to learn more about using Vespa
  </li><li>
    See <a href="jdisc/developing-applications.html">developing applications</a>
    on adding custom Java components to a Vespa application.
  </li><li>
    <a href="api.html">Vespa APIs</a> is useful to understand how to interface with Vespa
  </li><li>
    Explore the <a href="https://github.com/vespa-engine/sample-apps/tree/master">sample applications</a>
  </li><li>
    How to <a href="securing-your-vespa-installation.html">secure a Vespa installation</a>
  </li>
</ul>
