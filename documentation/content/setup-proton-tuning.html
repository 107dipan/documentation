---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "services.xml: content > engine > proton > tuning"
---

<p>
<em>tuning</em> configures the proton search core in <em>services.xml</em>
- refer to the <a href="../reference/services-content.html">reference</a>.
Read <a href="../proton.html#proton-maintenance-jobs">Proton maintenance jobs</a>
for background for these settings. <em>tuning</em> is not a required element:
<pre>
content
  engine
    proton
      <a href="#tuning">tuning</a>
        <a href="#searchnode">searchnode</a>
          <a href="#requestthreads">requestthreads</a>
            <a href="#requestthreads-search">search</a>
            <a href="#requestthreads-persearch">persearch</a>
            <a href="#requestthreads-summary">summary</a>
          <a href="#flushstrategy">flushstrategy</a>
            <a href="#flushstrategy-native">native</a>
              <a href="#flushstrategy-native-total">total</a>
                <a href="#flushstrategy-native-total-maxmemorygain">maxmemorygain</a>
                <a href="#flushstrategy-native-total-diskbloatfactor">diskbloatfactor</a>
              <a href="#flushstrategy-native-component">component</a>
                <a href="#flushstrategy-native-component-maxmemorygain">maxmemorygain</a>
                <a href="#flushstrategy-native-component-diskbloatfactor">diskbloatfactor</a>
                <a href="#flushstrategy-native-component-maxage">maxage</a>
              <a href="#flushstrategy-native-transactionlog">transactionlog</a>
                <a href="#flushstrategy-native-transactionlog-maxentries">maxentries</a>
                <a href="#flushstrategy-native-transactionlog-maxsize">maxsize</a>
              <a href="#flushstrategy-native-conservative">conservative</a>
                <a href="#flushstrategy-native-conservative-memory-limit-factor">memory-limit-factor</a>
                <a href="#flushstrategy-native-conservative-disk-limit-factor">disk-limit-factor</a>
          <a href="#resizing">resizing</a>
            <a href="#resizing-initialdocumentcount">initialdocumentcount</a>
            <a href="#resizing-amortize-count">amortize-count</a>
          <a href="#initialize">initialize</a>
            <a href="#initialize-threads">threads</a>
          <a href="#feeding">feeding</a>
            <a href="#feeding-concurrency">concurrency</a>
          <a href="#index">index</a>
            <a href="#index-io">io</a>
              <a href="#index-io-write">write</a>
              <a href="#index-io-read">read</a>
              <a href="#index-io-search">read</a>
            <a href="#index-warmup">warmup</a>
              <a href="#index-warmup-time">time</a>
              <a href="#index-warmup-unpack">unpack</a>
          <a href="#attribute">attribute</a>
            <a href="#attribute-io">io</a>
              <a href="#attribute-io-write">write</a>
          <a href="#removed-db">removed-db</a>
            <a href="#removed-db-prune">prune</a>
              <a href="#removed-db-prune-age">age</a>
              <a href="#removed-db-prune-interval">interval</a>
          <a href="#summary">summary</a>
            <a href="#summary-io">io</a>
              <a href="#summary-io-write">write</a>
              <a href="#summary-io-read">read</a>
            <a href="#summary-store">store</a>
              <a href="#summary-store-cache">cache</a>
                <a href="#summary-store-cache-maxsize">maxsize</a>
                <a href="#summary-store-cache-maxsize-percent">maxsize-percent</a>
                <a href="#summary-store-cache-compression">compression</a>
                  <a href="#summary-store-cache-compression-type">type</a>
                  <a href="#summary-store-cache-compression-level">level</a>
              <a href="#summary-store-logstore">logstore</a>
                <a href="#summary-store-logstore-maxfilesize">maxfilesize</a>
                <a href="#summary-store-logstore-chunk">chunk</a>
                  <a href="#summary-store-logstore-chunk-maxsize">maxsize</a>
                  <a href="#summary-store-logstore-chunk-maxentries">maxentries</a>
                  <a href="#summary-store-logstore-chunk-compression">compression</a>
                    <a href="#summary-store-logstore-chunk-compression-type">type</a>
                    <a href="#summary-store-logstore-chunk-compression-level">level</a>
</pre>
</p>



<h2 id="tuning">tuning</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="../reference/services-content.html#proton"><code>proton</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune settings for the search nodes in a content cluster - sub-element:
<table class="table">
    <thead>
    <tr>
        <th>Element</th><th>Required</th><th>Quantity</th>
    </tr>
    </thead><tbody>
    <tr>
        <td><a href="#searchnode"><code>searchnode</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr>
    </tbody>
</table>
</p>



<h2 id="searchnode">searchnode</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#tuning"><code>tuning</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune settings for search nodes in a content cluster - sub-elements:
<table class="table">
    <thead>
    <tr>
        <th>Element</th><th>Required</th><th>Quantity</th>
    </tr>
    </thead><tbody>
    <tr>
        <td><a href="#requestthreads"><code>requestthreads</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#flushstrategy"><code>flushstrategy</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#resizing"><code>resizing</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#initialize"><code>initialize</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#feeding"><code>feeding</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#index"><code>index</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#attribute"><code>attribute</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr><tr>
        <td><a href="#summary"><code>summary</code></a></td>
        <td class="required">No</td>
        <td>Zero or one</td>
    </tr>
    </tbody>
</table>
<pre>
&lt;tuning&gt;
    &lt;searchnode&gt;
        &lt;requestthreads&gt;&lt;/requestthreads&gt;
        &lt;flushstrategy&gt;&lt;/flushstrategy&gt;
        &lt;resizing&gt;&lt;/resizing&gt;
        &lt;initialize&gt;&lt;/initialize&gt;
        &lt;feeding&gt;&lt;/feeding&gt;
        &lt;index&gt;&lt;/index&gt;
        &lt;attribute&gt;&lt;/attribute&gt;
        &lt;summary&gt;&lt;/summary&gt;
    &lt;/searchnode&gt;
&lt;/tuning&gt;
</pre>
</p>



<h2 id="requestthreads">requestthreads</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune the number of request threads used on a search node - optional sub-elements:
<ul>
  <li id="requestthreads-search"><code>search</code>: Number of search threads, default 64</li>
  <li id="requestthreads-persearch"><code>persearch</code>: Number of search threads used per search,
    default 1</li>
  <li id="requestthreads-summary"><code>summary</code>: Number of summary threads, default 16</li>
</ul>
<pre>
&lt;requestthreads&gt;
    &lt;search&gt;64&lt;/search&gt;
    &lt;persearch&gt;1&lt;/persearch&gt;
    &lt;summary&gt;16&lt;/summary&gt;
&lt;/requestthreads&gt;
</pre>
Number of threads per search can adjusted down per rank-profile using <a href="../reference/search-definitions-reference.html#num-threads-per-search">num-threads-per-search</a>
</p>



<h2 id="flushstrategy">flushstrategy</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune the <em>native</em>-strategy for flushing components to disk -
a smaller number means more frequent flush:
<ul>
  <li><em>Memory gain</em> is how much memory can be freed by flushing a component</li>
  <li><em>Disk gain</em> is how much disk space can be freed by flushing a
    component (typically by using compaction)</li>
</ul>
Refer to <a href="../proton.html#proton-maintenance-jobs">Proton maintenance jobs</a>.
Optional sub-elements:
<ul>
    <li id="flushstrategy-native"><code>native</code>:
    <ul>
        <li id="flushstrategy-native-total"><code>total</code>
        <ul>
            <li id="flushstrategy-native-total-maxmemorygain"><code>maxmemorygain</code>:
            The total maximum memory gain (in bytes) for <em>all</em> components
            before running flush, default 4294967296 (4 GB)
            </li>
            <li id="flushstrategy-native-total-diskbloatfactor"><code>diskbloatfactor</code>:
            Trigger flush if the total disk gain (in bytes) for <em>all</em> components is larger
            than the factor times current total disk usage, default 0.2
            </li>
        </ul>
        </li><li id="flushstrategy-native-component"><code>component</code>
        <ul>
            <li id="flushstrategy-native-component-maxmemorygain"><code>maxmemorygain</code>:
            The maximum memory gain (in bytes) by <em>a single</em> component
            before running flush, default 1073741824 (1 GB)
            </li>
            <li id="flushstrategy-native-component-diskbloatfactor"><code>diskbloatfactor</code>:
            Trigger flush if the disk gain (in bytes) by <em>a single</em> component is larger than
            the given factor times the current disk usage by that component, default 0.2
            </li>
            <li id="flushstrategy-native-component-maxage"><code>maxage</code>:
            The maximum age (in seconds) of unflushed content for a single component
            before running flush, default 86400 (24h)
            </li>
        </ul>
        </li><li id="flushstrategy-native-transactionlog"><code>transactionlog</code>
        <ul>
            <li id="flushstrategy-native-transactionlog-maxentries"><code>maxentries</code>:
            <strong>DEPRECATED (use maxsize instead):</strong>
            The maximum number of entries in the <a href="../proton.html#transaction-log">transaction log</a>
            for a document type before running flush, default 1000000 (1 M)
            </li>
            <li id="flushstrategy-native-transactionlog-maxsize"><code>maxsize</code>:
            The total maximum size (in bytes) of <a href="../proton.html#transaction-log">transaction logs</a>
            for all document types before running flush, default 21474836480 (20 GB)
            </li>
        </ul>
        </li><li id="flushstrategy-native-conservative"><code>conservative</code>
        <ul>
            <li id="flushstrategy-native-conservative-memory-limit-factor"><code>memory-limit-factor</code>:
            When <a href="../reference/services-content.html#resource-limits">resource-limits</a> for memory is reached,
            flush more often by downscaling <code>total.maxmemorygain</code> and
            <code>component.maxmemorygain</code>, default 0.5
            </li>
            <li id="flushstrategy-native-conservative-disk-limit-factor"><code>disk-limit-factor</code>:
            When <a href="../reference/services-content.html#resource-limits">resource-limits</a> for disk is reached,
            flush more often by downscaling <code>transactionlog.maxsize</code>, default 0.5
            </li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
<pre>
&lt;flushstrategy&gt;
    &lt;native&gt;
        &lt;total&gt;
            &lt;maxmemorygain&gt;4294967296&lt;/maxmemorygain&gt;
            &lt;diskbloatfactor&gt;0.2&lt;/diskbloatfactor&gt;
        &lt;/total&gt;
        &lt;component&gt;
            &lt;maxmemorygain&gt;1073741824&lt;/maxmemorygain&gt;
            &lt;diskbloatfactor&gt;0.2&lt;/diskbloatfactor&gt;
            &lt;maxage&gt;86400&lt;/maxage&gt;
        &lt;/component&gt;
        &lt;transactionlog&gt;
            &lt;maxsize&gt;21474836480&lt;/maxsize&gt;
        &lt;/transactionlog&gt;
        &lt;conservative&gt;
            &lt;memory-limit-factor&gt;0.5&lt;/memory-limit-factor&gt;
            &lt;disk-limit-factor&gt;0.5&lt;/disk-limit-factor&gt;
        &lt;/conservative&gt;
    &lt;/native&gt;
&lt;/flushstrategy&gt;
</pre>
</p>



<h2 id="resizing">resizing</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune settings for data structure resizing to handle more or less documents.
Optional sub-elements:
<ul>
    <li id="resizing-initialdocumentcount"><code>initialdocumentcount</code>:
    The data structures used by the search node will be initialized to
    this number of documents before resizing - default 1024.
    Setting this value can help speed up the initial feed of documents.
    As <a href="../attributes.html">attribute</a> resize keep both
    current and new version in memory at the same time,
    peak memory usage more than doubles when growing the attribute.
    Setting <code>initialdocumentcount</code> higher than expected
    maximum number of documents per node will prevent a resize,
    which is useful if memory is the limiting sizing factor.
    </li>
    <li id="resizing-amortize-count"><code>amortize-count</code>:
    When growing the number of documents on a node the expansion of attributes
    will be spread out over N documents - default 1024. This is to spread the memory spikes out in time.
    You will not have to tune this. The default is good for all usecases. Documented for reference.
    </li>
</ul>
<pre>
&lt;resizing&gt;
    &lt;initialdocumentcount&gt;1024&lt;/initialdocumentcount&gt;
    &lt;amortize-count&gt;1024&lt;/amortize-count&gt;
&lt;/resizing&gt;
</pre>
</p>



<h2 id="initialize">initialize</h2>
<p>
<table class="table">
  <tr>
    <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
  </tr><tr>
    <td>Required:</td><td>No</td>
  </tr>
</table>
Tune settings related to how the search node (proton) is initialized. Optional sub-elements:
<ul>
  <li id="initialize-threads"><code>threads</code>:
    The number of initializer threads used for loading structures from disk at proton startup.
    The threads are shared between document databases when the value is larger than 0.
    Default value is the number of document databases + 1.
    <ul>
      <li>When set to larger than 1, document databases are initialized in parallel</li>
      <li>When set to 1, document databases are initialized in sequence</li>
      <li>When set to 0, 1 separate thread is used per document database
      and they are initialized in parallel.</li>
    </ul>
  </li>
</ul>
<pre>
&lt;initialize&gt;
   &lt;threads&gt;2&lt;/threads&gt;
&lt;/initialize&gt;
</pre>
</p>


<h2 id="feeding">feeding</h2>
<p>
<table class="table">
  <tr>
    <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
  </tr><tr>
    <td>Required:</td><td>No</td>
  </tr>
</table>
Tune settings related to how the search node (proton) is handling feed operations. Optional sub-elements:
<ul>
  <li id="feeding-concurrency"><code>concurrency</code>:
    A number between 0.0 and 1.0 that specifies the concurrency when handling feed operations, default 0.5.
    When set to 1.0 all cores on the cpu is utilized.
    See <a href="https://github.com/vespa-engine/vespa/blob/master/searchcore/src/vespa/searchcore/config/proton.def">feeding.concurrency in proton.def</a>
    for details on how this setting affects the thread pools used for feed operations.
  </li>
</ul>
<pre>
&lt;feeding&gt;
   &lt;concurrency&gt;0.8&lt;/concurrency&gt;
&lt;/feeding&gt;
</pre>
</p>


<h2 id="index">index</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune various aspect with the handling of disk and memory indexes. Optional sub-elements:
<ul>
    <li id="index-io"><code>io</code>
    <ul>
        <li id="index-io-write"><code>write</code>:
        Controls io write options used during index dump and fusion,
        values={normal,directio}, default directio
        </li>
        <li id="index-io-read"><code>read</code>:
        Controls io read options used during index dump and fusion,
        values={normal,directio}, default directio
        </li>
        <li id="index-io-search"><code>search</code>:
        Controls io read options used during search,
        values={mmap,populate}, default <code>mmap</code>. <code>populate</code> will eagerly touch all pages.
        </li>
    </ul>
    </li>
    <li id="index-warmup"><code>warmup</code>
    <ul>
        <li id="index-warmup-time"><code>time</code>:
        Specifies in seconds how long the index shall be warmed up before being switch in for serving.
        During warmup it will receive queries and posting lists will be iterated, but results ignored
        as they are duplicates of the live index. This will pull in the most important ones in the cache.
        However as warming up an index will occupy more memory do not turn it on unless you suspect you need it.
        And always benchmark to see if it is worth it.
        </li>
        <li id="index-warmup-unpack"><code>unpack</code>:
        Controls whether all posting features are pulled in to the cache, or only the most important.
        values={true, false}, default false.
        </li>
    </ul>
    </li>
</ul>
<pre>
&lt;index&gt;
    &lt;io&gt;
        &lt;write&gt;directio&lt;/write&gt;
        &lt;read&gt;directio&lt;/read&gt;
        &lt;search&gt;mmap&lt;/search&gt;
    &lt;/io&gt;
    &lt;warmup&gt;
        &lt;time&gt;60&lt;/time&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/warmup&gt;
&lt;/index&gt;
</pre>
</p>



<h2 id="attribute">attribute</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune various aspect with the handling of attribute vectors. Optional sub-elements:
<ul>
    <li id="attribute-io"><code>io</code>
    <ul>
        <li id="attribute-io-write"><code>write</code>:
        Controls io write options used during flushing of attribute vectors,
        values={normal,directio}, default directio
        </li>
    </ul>
    </li>
</ul>
<pre>
&lt;attribute&gt;
    &lt;io&gt;
        &lt;write&gt;directio&lt;/write&gt;
    &lt;/io&gt;
&lt;/attribute&gt;
</pre>
</p>

<h2 id="removed-db">removed-db</h2>
<p>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
Tune various aspect of the db of removed documents. Optional sub-elements:
<ul>
    <li id="removed-db-prune"><code>prune</code>
    <ul>
        <li id="removed-db-prune-age"><code>age</code>:
        Specifes how long (in seconds) we must remember removed documents before we can prune them away.
        Default is 2 weeks. This sets the upper limit on long a node can be down and still be accepted back
        in the system without having the index wiped. There is no point in having this any higher than the age of
        your documents. If you refeed your corpus every day there is no point in having this longer than 24 hours.
        </li>
        <li id="removed-db-prune-interval"><code>interval</code>:
        Specifies how often (in seconds) to prune old documents. Default is 600 which is 10 minutes. No need to change default.
        Exposed here for reference and for testing.
        </li>
    </ul>
    </li>
</ul>
<pre>
&lt;removed-db&gt;
    &lt;prune&gt;
        &lt;age&gt;86400&lt;/age&gt;
    &lt;/prune&gt;
&lt;/removed-db&gt;
</pre>
</p>



<h2 id="summary">summary</h2>
<table class="table">
    <tr>
        <td>Contained in:</td><td><a href="#searchnode"><code>searchnode</code></a></td>
    </tr><tr>
        <td>Required:</td><td>No</td>
    </tr>
</table>
<p>
Tune various aspect with the handling of document summary. Refer to
<a href="https://github.com/vespa-engine/vespa/blob/master/searchcore/src/vespa/searchcore/config/proton.def">
proton.def</a> to look for parameter values and defaults. Optional sub-elements:
</p>

<ul>
  <li id="summary-io"><code>io</code>
    <ul>
      <li id="summary-io-write"><code>write</code>:
        Controls io write options used during flushing of stored documents.
        See <em>summary.write.io</em></li>
      <li id="summary-io-read"><code>read</code>:
        Controls io read options used during reading of stored documents.
        Values are <code>directio</code> <code>mmap</code> <code>populate</code>.
        Default is <code>mmap</code. <code>populate</code> will do an eager mmap and touch all pages.</li>
    </ul>
  </li>

  <li id="summary-store"><code>store</code>
    <ul>
      <li id="summary-store-cache"><code>cache</code>: Used to tune the cache used by the document store.
        Enabled by default, using up to 5% of available memory.
        <ul>
          <li id="summary-store-cache-maxsize"><code>maxsize</code>:
          The maximum size of the cache in bytes. If given it takes presedence over <a href="#summary-store-cache-maxsize-percent">maxsize-percent</a>.
          See <em>summary.cache.maxbytes</em></li>
          <li id="summary-store-cache-maxsize-percent"><code>maxsize-percent</code>:
          The maximum size of the cache in percent of available memory. Default is 5%.</li>
          <li id="summary-store-cache-compression"><code>compression</code>
            <ul>
              <li id="summary-store-cache-compression-type"><code>type</code>:
                The compression type of the documents while in the cache.
                See <em>summary.cache.compression.type</em></li>
              <li id="summary-store-cache-compression-level"><code>level</code>:
                The compression level of the documents while in cache.
                See <em>summary.cache.compression.level</em></li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="summary-store-logstore"><code>logstore</code>:
        Used to tune the actual document store implementation (log-based).
        <ul>
          <li id="summary-store-logstore-maxfilesize"><code>maxfilesize</code>:
            The maximum size (in bytes) per summary file on disk.
            See <em>summary.log.maxfilesize</em> and
            <a href="../proton.html#document-store-compaction">
            document-store-compaction</a></li>
          <li id="summary-store-logstore-chunk"><code>chunk</code>
            <ul>
              <li id="summary-store-logstore-chunk-maxsize"><code>maxsize</code>:
                Maximum size (in bytes) of a chunk. See <em>summary.log.chunk.maxbytes</em></li>
              <li id="summary-store-logstore-chunk-maxentries"><code>maxentries</code>:
                <strong>DEPRECATED (use maxsize instead):</strong>
                Maximum number of documents in a chunk.
                See <em>summary.log.chunk.maxentries</em></li>
              <li id="summary-store-logstore-chunk-compression"><code>compression</code>
                <ul>
                  <li id="summary-store-logstore-chunk-compression-type"><code>type</code>:
                    Compression type of the documents.
                    See <em>summary.log.chunk.compression.type</em></li>
                  <li id="summary-store-logstore-chunk-compression-level"><code>level</code>:
                    Compression level of the documents.
                    See <em>summary.log.chunk.compression.level</em></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li> <!-- summary-store-logstore -->
    </ul>
  </li> <!-- summary-store -->
</ul>
<pre>
&lt;summary&gt;
    &lt;io&gt;
        &lt;write&gt;directio&lt;/write&gt;
        &lt;read&gt;mmap&lt;/read&gt;
    &lt;/io&gt;
    &lt;store&gt;
        &lt;cache&gt;
            &lt;maxsize&gt;0&lt;/maxsize&gt;
            &lt;compression&gt;
                &lt;type&gt;none&lt;/type&gt;
            &lt;/compression&gt;
        &lt;/cache&gt;
        &lt;logstore&gt;
            &lt;maxfilesize&gt;1000000000&lt;/maxfilesize&gt;
            &lt;chunk&gt;
                &lt;maxsize&gt;65536&lt;/maxsize&gt;
                &lt;compression&gt;
                    &lt;type&gt;zstd&lt;/type&gt;
                    &lt;level&gt;9&lt;/level&gt;
                &lt;/compression&gt;
            &lt;/chunk&gt;
        &lt;/logstore&gt;
    &lt;/store&gt;
&lt;/summary&gt;
</pre>
