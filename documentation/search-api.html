---
# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Search API"
---

<p>
Search with Vespa using HTTP GET requests. HTTP keepalive is supported.
<!-- ToDo check is POST supported? -->
Refer to the <a href="reference/search-api-reference.html">search API reference</a>.
The general form of a search request is:
<pre>
http://&lt;host&gt;:&lt;port&gt;/search/?&lt;param1=value1&gt;&amp;&lt;param2=value2&gt;&hellip;
</pre>
QRS (Query Result Server) is the service accepting Vespa search requests.
The only mandatory parameter is <code>query</code> or <code>yql</code> - examples:
<pre>
http://host:port/search/?query=rose
http://host:port/search/?query=kanoo%20bathing&amp;hits=10
</pre>
The last query has a query string consisting of multiple words. In
cases where the parameter values contains non-alphanumeric characters,
the values must be encoded according to standard URL encoding
rules. Thus, space is encoded as %20, + as %2b and so on -
see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>.
</p>


<!-- ToDo: move the legacy simple query language out of here -->

<h2 id="query-strings">Query Strings</h2>
<p>
The most important piece of the query request is the query string.
The query string contains the specification of which results the search should return,
typically some words which should be present in matching documents.
Queries are formulated in <a href="query-language.html">YQL</a>.</p>
Note: Also find the legacy
<a href="reference/simple-query-language-reference.html">simple query language reference</a>.
</p><p>
If Vespa cannot determine a valid search expression from the query string,
it will issue the error message <em>Null query</em>.
To troubleshoot, add <a href="reference/search-api-reference.html#tracelevel">&amp;tracelevel=2</a>
to the GET request. A missing yql parameter will also lead to this error message.
</p>



<h2 id="other-query-params">Other Query Parameters</h2>
<p>
In addition to the query string itself, Vespa accepts a number of
parameters which describes how to match documents, order results,
present results and how to provide additional information about the
hits. The following lists the most important parameters, a full
listing is found in the
<a href="reference/search-api-reference.html">search API reference</a>,
including information on search chains and query profiles.
It is also possible to use locations for <a href="geo-search.html">Geo search</a>.
<table class="table">
<thead>
<tr>
  <th>Parameter</th><th>Description</th>
  </tr>
</thead>
<tbody>
<tr><td><code>yql</code></td>
  <td>the query, described above</td></tr>
<tr><td><code>offset</code></td>
  <td>the (0-base) offset into the results, used for paging through a
      set of hits</td></tr>
<tr><td><code>hits</code></td>
  <td>the (max) number of hits to return</td></tr>
<tr><td><code>filter</code></td>
  <td>an additional <em>any</em> type query string used to limit or
      modify the query. This is typically used to add machine
      generated query terms or preset preferences to a user query,
      without having to do any string combination in the front
      end</td></tr>
<tr><td><code>tracelevel</code></td>
  <td>set to a positive integer to see tracing information in the
      query result. Higher numbers produce more tracing
      output.</td></tr>
<tr><td><code>sorting</code></td>
  <td>specifies result sorting, if sort by relevancy is not
      desired. See <a href="reference/sorting.html">sorting
      reference</a>.</td></tr>
<tr><td><code>timeout</code></td>
  <td>A floating point number giving number of seconds to wait for
      this query to finish. This overrides any default values set in query profiles,
      and any provider(backend) timeouts.</td></tr>
</tbody>
</table>
</p>


<h2 id="default-result-format">Default Result Format</h2>
<p>
The default output format is JSON as defined in the
<a href="./reference/default-result-format.html#default-json">reference</a>.
The basic structure is:
<pre>
{
    "root": {
        "children": [
            objects with same structure as root itself...
        ],
        "fields": {
            "document field name": "document field contents",
            â€¦
        }
    }
}
</pre>
As for a complete example of the structure:
<pre>
{
    "root": {
        "children": [
            {
                "children": [
                    {
                        "fields": {
                            "c": "d",
                            "uri": "http://localhost/1"
                        },
                        "id": "http://localhost/1",
                        "relevance": 0.9,
                        "types": [
                            "summary"
                        ]
                    }
                ],
                "id": "usual",
                "relevance": 1.0
            },
            {
                "fields": {
                    "e": "f"
                },
                "id": "type grouphit",
                "relevance": 1.0,
                "types": [
                    "grouphit"
                ]
            },
            {
                "fields": {
                    "description": "foo",
                    "uri": "http://localhost/"
                },
                "id": "http://localhost/",
                "relevance": 0.95,
                "types": [
                    "summary"
                ]
            }
        ],
        "coverage": {
            "coverage": 100,
            "documents": 500,
            "full": true,
            "nodes": 1,
            "results": 1,
            "resultsFull": 1
        },
        "errors": [
            {
                "code": 18,
                "message": "boom",
                "summary": "Internal server error."
            }
        ],
        "fields": {
            "totalCount": 130
        },
        "id": "toplevel",
        "relevance": 1.0
    }
}
</pre>
</p>
